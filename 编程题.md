___

### 矩阵中的路径 

请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。

[["a","b","c","e"],
["s","f","c","s"],
["a","d","e","e"]]

但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。

```java
class Solution {
    public boolean exist(char[][] board, String word) {
        char[] words = word.toCharArray();
        for(int i =0 ;i<board.length;i++){
            for(int j=0;j<board[0].length;j++){
                if(dfs(board,words,i,j,0)) return true;
            }
        }
        return false;
    }
    public boolean dfs(char[][]board,char[]words,int i,int j, int k){
        if(i<0||i>=board.length||j<0||j>=board[0].length||board[i][j]!=words[k]) return false;//边界判断
        if(k == words.length-1) return true;//终止条件
        char temp = board[i][j];
        board[i][j]='/';//防止回溯
        boolean res = dfs(board,words,i-1,j,k+1)||dfs(board,words,i,j-1,k+1)||
        dfs(board,words,i+1,j,k+1)||dfs(board,words,i,j+1,k+1);
        board[i][j]=temp;//匹配不成功，还原值
        return res;
    }
}
```

---

### 重建二叉树

输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

例如，给出

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：

```
   3  
  / \
  9  20
    /  \
   15   7
```



```java
/**

 \* Definition for a binary tree node.

 \* public class TreeNode {

 \*   int val;

 \*   TreeNode left;

 \*   TreeNode right;

 \*   TreeNode(int x) { val = x; }

 \* }

 */

class Solution {

  public TreeNode buildTree(int[] preorder, int[] inorder) {

​    if(preorder.length==0){

​      return null;

​    }

​    TreeNode root = new TreeNode();

​    root.val = preorder[0];

​    int i =0;

​    for(i =0;i<inorder.length;i++){

​      if(preorder[0]==inorder[i]){

​        break;

​      }

​    }

​    root.left = buildTree(Arrays.copyOfRange(preorder,1,i+1),Arrays.copyOfRange(inorder,0,i));//左子树

​    root.right = buildTree(Arrays.copyOfRange(preorder,i+1,preorder.length),Arrays.copyOfRange(inorder,i+1,inorder.length));
// 右子树
​    return root;

  }

}
```

### 机器人的运动范围

地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？

 

示例 1：

输入：m = 2, n = 3, k = 1
输出：3
示例 2：

输入：m = 3, n = 1, k = 0
输出：1

```java
class Solution {

  private int m;

  private int n;

  private int k;

  private boolean[][] visited;

  public int movingCount(int m, int n, int k) {

​    this.m = m;

​    this.n = n;

​    this.k = k;

​    this.visited = new boolean[m][n];//用来记录路径

​    return dfs(0,0,0,0);

  }
// 代表数组的大小和列和行下标的和 例如18 = 9
  public int dfs(int i, int j, int si,int sj){

​    if(i>=m||j>=n||k<si+sj||visited[i][j]) return 0;

​    visited[i][j]=true;

​    return 1+dfs(i+1,j,(i+1)%10!=0?si+1:si-8,sj)+dfs(i,j+1,si,(j+1)%10!=0?sj+1:sj-8);
// 其实就只有向下和向右两个方向 9-》10 = si-8

  }

}
```

### 剪绳子问题

给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

示例 1：

输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1
示例 2:

输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36

```
class Solution {
    public int cuttingRope(int n) {
        if(n <= 3) return n - 1;
        int a = n / 3, b = n % 3;
        if(b == 0) return (int)Math.pow(3, a);
        if(b == 1) return (int)Math.pow(3, a - 1) * 4;
        return (int)Math.pow(3, a) * 2;
    }
}


```

### 数值的次方问题

实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。

 

示例 1:

输入: 2.00000, 10
输出: 1024.00000
示例 2:

输入: 2.10000, 3
输出: 9.26100
示例 3:

输入: 2.00000, -2
输出: 0.25000
解释: 2-2 = 1/22 = 1/4 = 0.25

```
class Solution {
    public double myPow(double x, int n) {
        if(n<0){
            x = 1/x;
            n = -n;
        }
        double sum =1.0;
        while(n>0){//二分推导
            if((n%2)==1) sum = sum*x;//出现基数的情况
            x = x*x;
            n>>=1;
        }
        return sum;
    }
}
```

![image-20200802212228884](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200802212228884.png)

### 链表翻转

定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

 

示例:

输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
         if(head == null){
            return null;
        }
        ListNode prev = head;
        ListNode curr = head;
        ListNode next = head;
        
        ListNode node = head;
	// cur.next = prev , prev.next = next
	// cur 永远指向第一节点
	//每次用头插法，讲prev插入到之前的链表中
        while(curr.next != null){
            prev = curr.next;
            next = prev.next;

            curr.next = next;
            prev.next = node;
            node = prev;
        }
        return node;
    }
}
```

### 树的子结构

输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)

B是A的子结构， 即 A中有出现和B相同的结构和节点值。

例如:
给定的树 A:

     3
    / \
   4   5
  / \
 1   2
给定的树 B：

   4 
  /
 1
返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。

示例 1：

输入：A = [1,2,3], B = [3,1]
输出：false
示例 2：

输入：A = [3,4,5,1,2], B = [4,1]
输出：true

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isSubStructure(TreeNode A, TreeNode B) {
        return (A!=null&&B!=null)&&(recur(A,B)||isSubStructure(A.left,B)||isSubStructure(A.right,B));
    }
    boolean recur(TreeNode A, TreeNode B){
        if(B==null) return true;
        if(A==null||A.val!=B.val){
            return false;
        }
        return recur(A.left,B.left)&&recur(A.right,B.right);
    }
}
```

### 从上线下打印二叉树

从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。

 

例如:
给定二叉树: [3,9,20,null,null,15,7],

   3

   / \
  9  20
    /  \
   15   7
返回其层次遍历结果：

[
  [3],
  [9,20],
  [15,7]
]

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        if(root ==null){
            return null;
        }
        Queue queue = new LinkedList();
        List list = new ArrayList();
        if(root !=null){
            queue.add(root);
        }
        while(!queue.isEmpty()){
            List temp = new ArrayList();
            for(int i =queue.size();i>0;i-- ){
                TreeNode tree = (TreeNode)queue.poll();
                temp.add(tree.val);
                if(tree.left!=null) queue.add(tree.left);
                if(tree.right!=null) queue.add(tree.right);
            }
            list.add(temp);
        }
        return list;
    }
}
```

### 二叉树的中序遍历序列

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。

 

参考以下这颗二叉搜索树：

​	 5
​	/ \

   2   6
  / \
 1   3
示例 1：

输入: [1,6,3,2,5]
输出: false
示例 2：

输入: [1,3,2,6,5]
输出: true

```
class Solution {
    public boolean verifyPostorder(int[] postorder) {
         Stack<Integer> stack = new Stack<>();
        int root = Integer.MAX_VALUE; // 设置根为最大值
        // 后续的倒叙 是 根右左
        for(int i = postorder.length - 1; i >= 0; i--) {			// 判断左子树比根大
            if(postorder[i] > root) return false;
            while(!stack.isEmpty() && stack.peek() > postorder[i])
            	root = stack.pop(); // 找到根
                
            stack.add(postorder[i]);
        }
        return true;
    }
}
```

### 二叉树中和为某一值的路径

输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。

 

示例:
给定如下二叉树，以及目标和 sum = 22，

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
返回:

[
   [5,4,11,2],
   [5,8,4,5]
]

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    List<List<Integer>> res = new LinkedList();// 结果
    List<Integer> path = new LinkedList();// 路径信息
    public List<List<Integer>> pathSum(TreeNode root, int sum) {
        recur(root,sum);
        return res;
        
    }
    void recur(TreeNode root,int tar){
        if(root == null) return;
        path.add(root.val); // 加到路径
        tar-= root.val; // sum 减少
        if(root.left==null&&root.right==null&&tar==0){
            res.add(new LinkedList(path)); // 添加新路径
        }
        recur(root.left,tar);
        recur(root.right,tar);// 递归
        path.remove(path.size()-1);//移除最后一个
    }
}
```

### 二叉搜索树与双向链表

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。

 

为了让您更好地理解问题，以下面的二叉搜索树为例：

 

![img](https://assets.leetcode.com/uploads/2018/10/12/bstdlloriginalbst.png)

 

我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。

下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。

 

![img](https://assets.leetcode.com/uploads/2018/10/12/bstdllreturndll.png)

 

特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。

```
/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val,Node _left,Node _right) {
        val = _val;
        left = _left;
        right = _right;
    }
};
*/
class Solution {
    Node pre,head;
    public Node treeToDoublyList(Node root) {
        if(root ==null) return null;
        dfs(root);
        head.left = pre;// 最后一波操作，头指向部
        pre.right = head;// 尾部指向头
        return head;
    }
    void dfs(Node cur){
        if(cur ==null) return;
        dfs(cur.left);
        if(pre!=null){
            pre.right = cur;
        }else{
            head=cur;//找到了头
        }
        cur.left =pre; //进行连接操作
        pre = cur;

        dfs(cur.right);
    }
}
```

### 序列化二叉树

请实现两个函数，分别用来序列化和反序列化二叉树。

示例: 

你可以将以下二叉树：

    1
   / \
  2   3
     / \
    4   5

序列化为 "[1,2,3,null,null,4,5]"

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if(root==null){
            return new String("[]");
        }
        StringBuilder sb = new StringBuilder();
        sb.append("[");
        Queue queue = new LinkedList();
        queue.add(root);
        while(!queue.isEmpty()){
            TreeNode node =(TreeNode) queue.poll();
            if(node!=null){
                sb.append(node.val);
                sb.append(",");
                queue.add(node.left);// 不为空次啊有左根右
                queue.add(node.right);
            }else{
                sb.append("null");
                sb.append(",");
            }
            
        }
        sb.deleteCharAt(sb.length()-1);// 去除最后一个都好
        sb.append("]");
        return sb.toString();
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        if(data.length()==2){
            return null;
        }
        data = data.substring(1,data.length()-1);//去掉 [ ]
        String[] arr = data.split(",");//分成数组
        TreeNode root = new TreeNode(Integer.parseInt(arr[0]));
        Queue queue = new LinkedList();
        queue.add(root);// 一定是吧TreeNode  类型加入到队列
        int i =1;
        while(!queue.isEmpty()&&i<arr.length){
            TreeNode node = (TreeNode)queue.poll();
            if(i<arr.length&&!arr[i].equals("null")){
                node.left = new TreeNode(Integer.parseInt(arr[i]));
                queue.add(node.left);
            }
            i++;
            if(i<arr.length&&!arr[i].equals("null")){
                node.right = new TreeNode(Integer.parseInt(arr[i]));
                queue.add(node.right);
            }
            i++;
        }
        return root;
    }
}

// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.deserialize(codec.serialize(root));
```


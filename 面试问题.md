```bash
# 一级标题
## 二级标题
### 三级标题
#### 四级标题
##### 五级标题
###### 六级标题
```

```swift
//形式一
+ a
+ b
+ c
//形式二
- d
- e
- f
//形式三
* g
* h
* i
```

```cpp
//正常形式
1. abc
2. bcd
3. cde
//错序效果
2. fgh
3. ghi
5. hij
```

```cpp
//无序列表嵌套
+ 123
    + abc
    + bcd
    + cde
+ 465
+ 789
//有序列表嵌套
1. abcd
    1. abcde
    2. abcde
    3. abcde
2. bcde
3. cdef
```

```ruby
> 一级引用
>> 二级引用
>>> 三级引用
>>>> 四级引用
>>>>> 五级引用
>>>>>> 六级引用
```

~~~go
//大量代码    
```
        daliangdaima,xuyaoduohangshiyong
        daliangdaima,xuyaoduohangshiyong
        daliangdaima,xuyaoduohangshiyong
        daliangdaima,xuyaoduohangshiyong
        daliangdaima,xuyaoduohangshiyong
    ```
~~~

```undefined
//分割线
---
- - -
------
***
* * *
******
___
_ _ _
______
```

```undefined
//强调字体
*md*    
**md**
_md_   
 __md__
```

```undefined
\\
\*
\+
\-
\`
\_
```

```undefined
~~删除~~
```

---



### Java中的filter 的

#### 三个参数

ServletRequest

ServletResponse 

FilterChain

#### 生命周期

init

doFilter

destory

#### web.xml 配置

<filter>

<filter-name>

<filter-class>

<init-param>

<param-name>

<param-value>

<filter-mapping>

<filter-name>

<url-pattern>

#### 应用

编码格式的转换 和 登录过滤

---

### Maven

#### 作用

标准化的项目结构

标准化的构建流程

管理机制

#### pom.xml说明

groupId 公司或者组织的id

artifactId 项目名称

version 

dependency 依赖

parent 父项目

dependencies 项目依赖

dependency 具体的依赖

#### 生命周期

##### 标准生命周期

clean 项目的清理

default/build 项目的部署

site 项目站点文档创建处理

###### default/build 生命周期

validata 验证项目

compile

test

package

verify 检查

intall 安装，将打包的项目安装到本地

deploy 部署，拷贝工程到远程仓库有

###### clean 的生命周期

pre-clean

clean

post-clean

###### site 生命周期

pre-site

site

post-site

site-deploy

---

### Vue

使用基于 HTML 的模板语法，声明式的将 DOM 绑定到 Vue 实例数据

#### 安装

npm install 安装依赖

npm run dev 运行程序

#### 语句

v-if 条件判断

v-else else 块

v-else-if else if 块

v-for 条件循环,如果是键值对，可使用多个参数，例如v-for="(value,key) in object"

#### 属性

计算属性 computed 只有在依赖改变时，才会重新取值

监听属性 watch 用于响应数据的变化

data 的数据，变量不用引号，在 main 中是属性，在组件中是函数，好处是每个实例维护一份被返回对象的独立拷贝

#### 指令

v-html 绑定 data 中的变量，用于输出 html 代码

v-bind/: 双向绑定 data 中的变量，也可以绑定 style 和 class，例如v-bind:class=""

v-model 单向绑定 data 中的变量，表单实现双向绑定	

v-show 根据条件来展示元素

v-on/@ 对于事件的处理，例如v-on:keyup.enter=""

#### 组件

vue 组件 封装可用的代码，全局和局部组件，父组件通过 props 把数据传给子组件，子组件通过 $on 监听事件和 $emit 触发事件，传回给父组件

#### 路由

下载 npm run vue-router

##### router-link

to 当被电击是会立即把 to 的值传到 router.push(),这个值可以是一个字符串或者是描述目标位置的对象

replace 调用的是 rourer.replace() 导航后不会留下 history 记录

append 追加路径属性

tag <router-link>想要渲染成某种标签

acitve-class 链接激活时使用的 CSS 类名

event  用来触发导航事件

---



#### 后端生成文档

1. 使用AdobeAcrobatpro，设计pdf文档模板
2. 获取模板文档路径
3. HttpServletResponse 设置头，content-type 设置为 Application/pdf
4. 读取模板，对象PdfReader
5. 转换成字节流
6. 创建可操作的 pdf 模板对象，PdfStamper
7. 封装数据，AcoFields
8. 填充数据
9. 设置是否可修改
10. 关闭资源

---

### JPA

创建表

自动实现保存和删除

#### JPA Hibernate 关系

JPA 是一种规范，不是框架

Hibernate 是JPA的一种实现，是框架

#### 注解

@Entity

@Table

@Id

@GenterateValue 指定如何标识属性可以被初始化

@Transient

@Column

@TableGenerator

#### 定义JPA接口

public interface XXRepository extends JpaRepository<XX,String>{}

#### JPA关键字

And

Or

Is/Equals

Between

LessThan

LessThanEqual

GreaterThan

GreaterThanEqual

After

Before

IsNull

Like

NotLike

OrderBy

### MyBatis

#### 什么是mybatis

MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。

#### 功能框架

1. API接口层：提供给外部使用的接口API，开发人员通过这些本地API来操纵数据库。接口层一接收到调用请求就会调用数据处理层来完成具体的数据处理。
2. 数据处理层：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的目的是根据调用的请求完成一次数据库操作。
3. 基础支撑层：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑。

#### 优点

- 简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。
- 灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。 sql写在xml里，便于统一管理和优化。通过sql基本上可以实现我们不使用数据访问框架可以实现的所有功能，或许更多。
- 解除sql与程序代码的耦合：通过提供DAL层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。
- 提供映射标签，支持对象与数据库的orm字段关系映射
- 提供对象关系映射标签，支持对象关系组建维护
- 提供xml标签，支持编写动态sql。

#### 缺点

- 编写SQL语句时工作量很大，尤其是字段多、关联表多时，更是如此。
- SQL语句依赖于数据库，导致数据库移植性差，不能更换数据库。
- 框架还是比较简陋，功能尚有缺失，虽然简化了数据绑定代码，但是整个底层数据库查询实际还是要自己写的，工作量也比较大，而且不太容易适应快速数据库修改。
- 二级缓存机制不佳

#### xml配置

MyBatis 的配置文件包含了影响 MyBatis 行为甚深的设置（settings）和属性（properties）信息。

##### properties

这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。

<properties resource="org/mybatis/example/config.properties">  

<property name="username" value="dev_user"/>  

<property name="password" value="F2Fa3!33TYyg"/> 

</properties>

如果属性在不只一个地方进行了配置，那么 MyBatis 将按照下面的顺序来加载：

因此，通过方法参数传递的属性具有最高优先级，resource/url 属性中指定的配置文件次之，最低优先级的是 properties 属性中指定的属性。

##### settings

这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。下表描述了设置中各项的意图、默认值等。

<settings>   

<setting name="cacheEnabled" value="true"/>   

<setting name="lazyLoadingEnabled" value="true"/>   

<setting name="multipleResultSetsEnabled" value="true"/>   

<setting name="useColumnLabel" value="true"/>   

<setting name="useGeneratedKeys" value="false"/>   

<setting name="autoMappingBehavior" value="PARTIAL"/>   

<setting name="defaultExecutorType" value="SIMPLE"/>   

<setting name="defaultStatementTimeout" value="25"/>   

<setting name="safeRowBoundsEnabled" value="false"/>   

<setting name="mapUnderscoreToCamelCase" value="false"/>   

<setting name="localCacheScope" value="SESSION"/>   

<setting name="jdbcTypeForNull" value="OTHER"/>   

<setting name="lazyLoadTriggerMethods" value="equals,clone,hashCode,toString"/> 

</settings>

##### typeAliases

类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。

<typeAliases>   

<typeAlias alias="Author" type="domain.blog.Author"/>   

<typeAlias alias="Blog" type="domain.blog.Blog"/>   

<typeAlias alias="Comment" type="domain.blog.Comment"/>   

<typeAlias alias="Post" type="domain.blog.Post"/>   

<typeAlias alias="Section" type="domain.blog.Section"/>   

<typeAlias alias="Tag" type="domain.blog.Tag"/> 

</typeAliases>//为全限定名设置一个短的名字

<typeAliases>  <package name="domain.blog"/> </typeAliases> // 配置包名

@Alias("author") //注解方式

##### typeHandlers

无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。 具体做法为：实现 `org.apache.ibatis.type.TypeHandler` 接口， 或继承一个很便利的类 `org.apache.ibatis.type.BaseTypeHandler`， 然后可以选择性地将它映射到一个 JDBC 类型。

<typeHandlers>  

<typeHandler handler="org.mybatis.example.ExampleTypeHandler"/> 

</typeHandlers>

##### 处理枚举类型

若想映射枚举类型 `Enum`，则需要从 `EnumTypeHandler` 或者 `EnumOrdinalTypeHandler` 中选一个来使用。

比如说我们想存储取近似值时用到的舍入模式。默认情况下，MyBatis 会利用 `EnumTypeHandler` 来把 `Enum` 值转换成对应的名字。

注意 `EnumTypeHandler` 在某种意义上来说是比较特别的，其他的处理器只针对某个特定的类，而它不同，它会处理任意继承了 `Enum` 的类。

使用 Mapper 接口，并不对接口进行实现，底层使用动态代理来实现，接口的全限定名就是 namespace 的值，当调用接口方法时，全限定名+方法名拼接成的 key 对应的一个唯一的 MappedStatement 

##### 配置环境

MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中， 现实情况下有多种理由需要这么做。例如，开发、测试和生产环境需要有不同的配置；或者共享相同 Schema 的多个生产数据库， 想使用相同的 SQL 映射。许多类似的用例。

不过要记住：尽管可以配置多个环境，每个 SqlSessionFactory 实例只能选择其一。

所以，如果你想连接两个数据库，就需要创建两个 SqlSessionFactory 实例，每个数据库对应一个。而如果是三个数据库，就需要三个实例，依此类推。

<environments default="development">   

<environment id="development">     

<transactionManager type="JDBC">       

<property name="..." value="..."/>     

</transactionManager>     

<dataSource type="POOLED">       

<property name="driver" value="${driver}"/>       

<property name="url" value="${url}"/>       

<property name="username" value="${username}"/>       

<property name="password" value="${password}"/>     

</dataSource>   

</environment> 

</environments>

##### 事务

<transactionManager type="MANAGED">  <property name="closeConnection" value="false"/> </transactionManager>

##### 数据源

###### UNPOLLED

这个数据源的实现只是每次被请求时打开和关闭连接。虽然一点慢，它对在及时可用连接方面没有性能要求的简单应用程序是一个很好的选择。 不同的数据库在这方面表现也是不一样的，所以对某些数据库来说使用连接池并不重要，这个配置也是理想的。

- `driver` – 这是 JDBC 驱动的 Java 类的完全限定名（并不是JDBC驱动中可能包含的数据源类）。
- `url` – 这是数据库的 JDBC URL 地址。
- `username` – 登录数据库的用户名。
- `password` – 登录数据库的密码。
- `defaultTransactionIsolationLevel` – 默认的连接事务隔离级别。

###### POLLED

这种数据源的实现利用"池"的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。 这是一种使得并发 Web 应用快速响应请求的流行处理方式。

- `poolMaximumActiveConnections` – 在任意时间可以存在的活动（也就是正在使用）连接数量，默认值：10
- `poolMaximumIdleConnections` – 任意时间可能存在的空闲连接数。
- `poolMaximumCheckoutTime` – 在被强制返回之前，池中连接被检出（checked out）时间，默认值：20000 毫秒（即 20 秒）
- `poolTimeToWait` – 这是一个底层设置，如果获取连接花费的相当长的时间，它会给连接池打印状态日志并重新尝试获取一个连接（避免在误配置的情况下一直安静的失败），默认值：20000 毫秒（即 20 秒）。
- `poolPingQuery` – 发送到数据库的侦测查询，用来检验连接是否处在正常工作秩序中并准备接受请求。默认是"NO PING QUERY SET"，这会导致多数数据库驱动失败时带有一个恰当的错误消息。
- `poolPingEnabled` – 是否启用侦测查询。若开启，也必须使用一个可执行的 SQL 语句设置 `poolPingQuery` 属性（最好是一个非常快的 SQL），默认值：false。
- `poolPingConnectionsNotUsedFor` – 配置 poolPingQuery 的使用频度。这可以被设置成匹配具体的数据库连接超时时间，来避免不必要的侦测，默认值：0（即所有连接每一时刻都被侦测 — 当然仅当 poolPingEnabled 为 true 时适用）。

###### JNDI

这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。

- `initial_context` – 这个属性用来在 InitialContext 中寻找上下文（即，initialContext.lookup(initial_context)）。这是个可选属性，如果忽略，那么 data_source 属性将会直接从 InitialContext 中寻找。
- `data_source` – 这是引用数据源实例位置的上下文的路径。提供了 initial_context 配置时会在其返回的上下文中进行查找，没有提供时则直接在 InitialContext 中查找。

##### 映射器

既然 MyBatis 的行为已经由上述元素配置完了，我们现在就要定义 SQL 映射语句了。但是首先我们需要告诉 MyBatis 到哪里去找到这些语句。 Java 在自动查找这方面没有提供一个很好的方法，所以最佳的方式是告诉 MyBatis 到哪里去找映射文件。你可以使用相对于类路径的资源引用， 或完全限定资源定位符（包括 `file:///` 的 URL），或类名和包名等。

<mappers>  <mapper resource="org/mybatis/builder/AuthorMapper.xml"/>  

<mapper resource="org/mybatis/builder/BlogMapper.xml"/>  

<mapper resource="org/mybatis/builder/PostMapper.xml"/> 

</mappers>

#### 映射文件

##### select

```
<select id="selectPerson" parameterType="int" resultType="hashmap">  SELECT * FROM PERSON WHERE ID = #{id} </select>    
<select #常用参数
  id="selectPerson"
  parameterType="int"
  parameterMap="deprecated"
  resultType="hashmap"
  resultMap="personResultMap"
  flushCache="false"
  useCache="true"
  timeout="10000"
  fetchSize="256"
  statementType="PREPARED"
  resultSetType="FORWARD_ONLY"> 
```



##### insert updata delete

```
<insert  id="insertAuthor"  parameterType="domain.blog.Author"  flushCache="true"  statementType="PREPARED"  keyProperty=""  keyColumn=""  useGeneratedKeys=""  timeout="20"> 
<update  id="updateAuthor"  parameterType="domain.blog.Author"  flushCache="true"  statementType="PREPARED"  timeout="20"> 
<delete  id="deleteAuthor"  parameterType="domain.blog.Author"  flushCache="true"  statementType="PREPARED"  timeout="20">
```

##### sql

这个元素可以被用来定义可重用的 SQL 代码段，可以包含在其他语句中。

<sql id="userColumns"> ${alias}.id,${alias}.username,${alias}.password </sql>

##### 参数

```
<select id="selectUsers" resultType="User">
  select id, username, password
  from users
  where id = #{id}
</select>
```

##### 字符串替换

${}这种方式接受从用户输出的内容并提供给语句中不变的字符串是不安全的，会导致潜在的 SQL 注入攻击，因此要么不允许用户输入这些字段，要么自行转义并检验。

##### ResultsMap （一张表中）

```
<!-- In mybatis-config.xml file --> 

<typeAlias type="com.someapp.model.User" alias="User"/> 

<!-- In SQL Mapping XML file --> 
<select id="selectUsers" resultType="User">  select id, username, hashedPassword  from some_table  where id = #{id} </select>
```

##### 高级结果映射 （多张表中）

<!-- Very Complex Statement --> 

```
<select id="selectBlogDetails" resultMap="detailedBlogResultMap">  
select       B.id as blog_id,       B.title as blog_title,       B.author_id as blog_author_id,       A.id as author_id,       A.username as author_username,       A.password as author_password,       A.email as author_email,       A.bio as author_bio,       A.favourite_section as author_favourite_section,       P.id as post_id,       P.blog_id as post_blog_id,       P.author_id as post_author_id,       P.created_on as post_created_on,       P.section as post_section,       P.subject as post_subject,       P.draft as draft,       P.body as post_body,       C.id as comment_id,       C.post_id as comment_post_id,       C.name as comment_name,       C.comment as comment_text,       T.id as tag_id,       T.name as tag_name  from Blog B       
left outer join Author A on B.author_id = A.id       
left outer join Post P on B.id = P.blog_id       
left outer join Comment C on P.id = C.post_id       
left outer join Post_Tag PT on PT.post_id = P.id       
left outer join Tag T on PT.tag_id = T.id  where B.id = #{id} 
</select>
```



#### 动态sql

###### if

```
<select id="findActiveBlogWithTitleLike"     resultType="Blog">  
SELECT * FROM BLOG   WHERE state = ‘ACTIVE’   
<if test="title != null">    
AND title like #{title}  
</if> 
</select>
```

##### choose when otherwise (Java 的 switch 语句，choose 为 switch，when 为 case，otherwise 则为 default。)

```
<select id="findActiveBlogLike"
     resultType="Blog">
  SELECT * FROM BLOG WHERE state = ‘ACTIVE’
  <choose>
    <when test="title != null">
      AND title like #{title}
    </when>
    <when test="author != null and author.name != null">
      AND author_name like #{author.name}
    </when>
    <otherwise>
      AND featured = 1
    </otherwise>
  </choose>
</select>
```

##### trim where set

where 会帮你自动修剪条件

```
<select id="findActiveBlogLike"
     resultType="Blog">
  SELECT * FROM BLOG 
  <where> 
    <if test="state != null">
         state = #{state}
    </if> 
    <if test="title != null">
        AND title like #{title}
    </if>
    <if test="author != null and author.name != null">
        AND author_name like #{author.name}
    </if>
  </where>
</select>
<trim prefix="WHERE" prefixOverrides="AND |OR ">  ...  </trim> 
```

set 元素可以被用于动态包含需要更新的列

```
<update id="updateAuthorIfNecessary">
  update Author
    <set>
      <if test="username != null">username=#{username},</if>
      <if test="password != null">password=#{password},</if>
      <if test="email != null">email=#{email},</if>
      <if test="bio != null">bio=#{bio}</if>
    </set>
  where id=#{id}
</update>
```

##### foreach

动态 SQL 的另外一个常用的必要操作是需要对一个集合进行遍历

```
<select id="selectPostIn" resultType="domain.blog.Post">
  SELECT *
  FROM POST P
  WHERE ID in
  <foreach item="item" index="index" collection="list"
      open="(" separator="," close=")">
        #{item}
  </foreach>
</select>
```

#### 目录结构

```
/my_application
  /bin
  /devlib
  /lib                <-- MyBatis *.jar文件在这里。
  /src
    /org/myapp/
      /action
      /data           <-- MyBatis配置文件在这里, 包括映射器类, XML配置, XML映射文件。
        /mybatis-config.xml
        /BlogMapper.java
        /BlogMapper.xml
      /model
      /service
      /view
    /properties       <-- 在你XML中配置的属性 文件在这里。
  /test
    /org/myapp/
      /action
      /data
      /model
      /service
      /view
    /properties
  /web
    /WEB-INF
      /web.xml
```



### 树形结构的



### 存储

设置一个 superId ,当数据是第一级树的时候，设置为空，通过一级查找二级，依次下去。

### 常用的Utils

OSUtils 负责不同的操作系统，路径的选择

TreeUtils 树形结构utils

BeanUtils 负责bean的操作

### JsonResponse

对返回值的封装，通过code 说明状态码，通过msg说明返回的信息，还有一个泛型的data,返回响应数据。

构造方法有JsonResponse()

JsonResponse( code,message);

JsonResponse(code,message,data)

静态方法success() , 返回一个code 为0，msg为空的JsonResponse 对象

静态方法success(T data),返回一个code 为0，msg为空的，值为data的JsonResponse 对象

静态方法success(String message,T data)，返回一个code为0，message ，数据是data的JsonResponse() 方法

静态方法fail(String message),返回状态码为1， message信息

静态方法fail(int code，String message)，返回状态为code，messge信息

### 用户权限控制



### 文件的导入导出

### docker



### Java基础

#### Java 中为什么只有值传递

java 中的对象采用的不是应用调用，而是值传递

#### hashCode()  和 equals

Object 中实现了 hashCode() ，hashCode() 是两个对象equals 前的操作，haCode() 的计算方法一般通过一个质数的乘法完成，比如String 的hashCode 是通过31*hash+string[i]，每个字符串有一个特定的hash，如果hash相同，他们可能equals，如果他们equals，那么他们的hash一定相同。hashCode 可以大大减小数据的之间的对比次数，如果比较两个string 是否equals 那么正常的思路就是一个个比，这样效率太差，可通过 hashCode 来先预判一下，两个string是否相等，提高效率，缩小查找的成本。两个 hashCode 值相等，这种叫 hash 冲突。

#### String StringBuilder StringBuffer

String 对象都是用 final 修饰的，内容不可变，但是指向是可以改变的

StringBuilder 是线程不安全的，通过apped 可以追加string 

StringBuffer 是线程安全的，通过append 可以追加string，所有的方法都是加了synchronized 的

#### 反射机制



---



# 1.1. Java 入门（基础概念与常识）

## 1.1.1. Java 语言有哪些特点

简单易学、支持面向对象、支持一次编译多平台使用、支持多线程、支持网络编程、取消了指针的使用，取消了多继承

可靠安全

## 1.1.2. 关于 JVM JDK 和 JRE 最详细通俗的解答

### 1.1.2.1. JVM

java virtual machine， 负责加载.class 文件，不同的系统有不同的实现。一次编译，随处执行

### 1.1.2.2. JDK 和 JRE

JDK：是java development kit ， 包含了运行时环境、编译、还有常用的基础包，如果要编写代码推荐用这个。

JRE：是java runtime environment ， 只是包含了运行时环境，如果要跑已经编译好的.class 文件可以胜任。

## 1.1.3. Oracle JDK 和 OpenJDK 的对比

Open JDK 由sun公司开放源码，由Oracle 工程师维护

## 1.1.4. Java 和 C++的区别

c++ ：带指针，支持多继承，无内存管理（手动释放）,字符串以\0结束

java：不带指针，不支持多继承，支持单继承，实现多接口，有内存管理（自动释放），java 没有结束这个概念

## 1.1.5. 什么是 Java 程序的主类 应用程序和小程序的主类有何不同

public static void main(String[] args){} ，只能有一个，不一定是public

java 小程序中，继承JApplet 和 Applet  的子类 ，必须是public

## 1.1.6. Java 应用程序与小程序之间有哪些差别

应用程序的主线程是main（）方法，小程序没有main，主要是浏览器运行init（） 和run（） 来启动

### 1.1.7. import java 和 javax 有什么区别

java 和 javax 本质上是与java 编程语言的上下文一起使用的包，api 所必须的包是Java， javax 包含java 的扩展。javax 为标注api的一部分。实际上没有区别，都是一个名字。

### 1.1.8. 为什么说 Java 语言编译与解释并存

有编译语言的特征，也有解释语言的特征。先经过编译，编译成.class 文件，然后字节码文件由java 解释器来解释执行。就像一本英文的书，先翻译成中文，然后再去阅读。

# 1.2. Java 语法

## 1.2.1. 字符型常量和字符串常量的区别

字符型是单引号，只占两个字节，相当于一个整型值

字符串是双引号，占据若干个字节，相当于一个地址（指向内存中存放的位置）

### 1.2.2. 关于注释

单行注释 // 

多行/*  */

### 1.2.3. 标识符和关键字的区别是什么

标识符：字母、数字、下划线、$, 不以数字开头

关键字：变量修饰符、程序控制、错误处理、包相关

### 1.2.4. Java中有哪些常见的关键字

|                      |          |            |          |              |            |           |        |
| -------------------- | -------- | ---------- | -------- | ------------ | ---------- | --------- | ------ |
| 访问控制             | private  | protected  | public   |              |            |           |        |
| 类，方法和变量修饰符 | abstract | class      | extends  | final        | implements | interface | native |
|                      | new      | static     | strictfp | synchronized | transient  | volatile  |        |
| 程序控制             | break    | continue   | return   | do           | while      | if        | else   |
|                      | for      | instanceof | switch   | case         | default    |           |        |
| 错误处理             | try      | catch      | throw    | throws       | finally    |           |        |
| 包相关               | import   | package    |          |              |            |           |        |
| 基本类型             | boolean  | byte       | char     | double       | float      | int       | long   |
|                      | short    | null       | true     | false        |            |           |        |
| 变量引用             | super    | this       | void     |              |            |           |        |
| 保留字               | goto     | const      |          |              |            |           |        |

### 1.2.5. 自增自减运算符

i++  i--;

### 1.2.6. continue、break、和return的区别是什么

continue 结束本次循环

break 跳出循环体

return 结束方法的运行

### 1.2.7. Java泛型了解么？什么是类型擦除？介绍一下常用的通配符

泛型：常用于集合，就是不确定数据类型，使用T 真能代替对象类型，可以让代码的灵活性和复用性得以增强，本质是参数化类型

java 中的泛型是伪泛型，java编译期间，所有的泛型信息会被擦除，这也就是所说的类型擦除，如果没有指定具体的类型，会按照Object 类型进行处理

通配符：

？ 表示不确定的 java 类型

T (type) 表示具体的一个java类型

K V (key value) 分别代表java键值中的Key Value

E (element) 代表Element

- T 只有extends一种限定方式，<T extends List>是合法的，<T super List>是不合法的
- ？有extends与super两种限定方式，即<? extends List> 与<? super List>都是合法的
- T 用于泛型类和泛型方法的定义。？用于泛型方法的调用和形参
- 对于 ？super （下界）的通配符限定泛型，我们可以读取其中的元素，但读取出来的元素会变为 Object 类型。
- 对于 ？ extends (上界)的通配符限定泛型，我们无法向里面添加元素(只可以添加null)，只能读取其中的元素。

序列化一个泛型类，然后反序列化，丧失原有的类型信息。

### 1.2.8. ==和equals的区别

Object 中的 equals 就是比较的内存地址，好多类都会重写equals（），来实现内容的比较。

而平常我们用的== 就是比较的内存地址，基本数据类型，比较时就是比较的值，而对象类型比较时，比较的是内存地址

### 1.2.9. hashCode()与 equals()

hashCode（） 从Object 中就实现了 ，是一个本地方法，一般返回一个对象的哈希码（是一个整数），减少equals 的次数。

equals（）在Object 中也有实现，他比较的是内存地址。String 类中比较的是String 的内容。

重写equals（） 时，必须重写hashCode()，字符串堆hash 进行加功31*hash+val[i]，先比较类型，和内存值，如果相等返回true，不相等分别将String 转换为 array， 然后一次比较。

hashCode 相等，equals 可能不相等；hashCode不相等，equals 一定不相等。

## 1.3. 基本数据类型

### 1.3.1. Java中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？

就是基本类型和引用类型

byte-Byte-1

short-Short-2

int -Integer-4

long-Long-8

boolean-Boolean-1

char-Charecter-2

float-Floa-4

double-Double-8



### 1.3.2. 自动装箱与拆箱

装箱：就是将基本类型转化为包装类型，Integer i= 5；,通过valueOf实现

拆箱：就是将包装类型转化为基本类型	int a = i;，通过intValue实现

### 1.3.3. 8种基本类型的包装类和常量池

常量池技术，就是在池中缓存一些数据，Byte，Short，Integer，Long，面四种包装类型都默认创建【-128,127】 的相应的缓存数据;Character 默认创建【0，127】范围的缓存数据。Boolean 直接返回 true 和 false。如果超出范围，会返回一个新的对象。（这些都是通过valueOf 方法实现的。

## 1.4. 方法（函数）

### 1.4.1. 什么是方法的返回值?返回值在类的方法里的作用是什么?

返回值，就是通过return 返回的值，可以指定为基本数据类型和对象类型。作用时返回一个结果。

### 1.4.2. 为什么 Java 中只有值传递？

是的，方法中的形参值，是实参的一个拷贝，如果是基本数据类型，那就拷贝是原来的值，如果是引用类型，那么拷贝的是引用的值（也就是地址）。形参属于局部变量，在函数结束的时候，会释放。如果通过引用类型对数据进行修改，那么原来指向的数据也会改变，比如对象和数组。

### 1.4.3. 重载和重写的区别 

重载：根据不同的参数输入，做不同的处理。参数必须不同，返回值类型可以不同，异常可以不同，访问修饰符可以不同，编译期间。

重写：是子类继承父类的相同方法，相同的代码，做出不同的反应。返回值、方法名、参数列表必须相同，异常小于等于父，访问权限大于等于父，运行期间。

### 1.4.4. 深拷贝 vs 浅拷贝

深拷贝：不光拷贝引用类型，同时引用的数据也要拷贝一份。

浅拷贝：只是拷贝引用类型。

# Java 面向对象

## 2.1. 类和对象

### 2.1.1. 面向对象和面向过程的区别

面向对象：性能差，易维护，易扩展，易复用。

面向过程：性能好，不易维护，不易扩展，不易复用。

### 2.1.2. 构造器 Constructor 是否可被 override?

可以，对不同的数据，给出不同的处理。

### 2.1.3. 在 Java 中定义一个不做事且没有参数的构造方法的作用

如果你不写构造函数的话，jvm会自动帮你生成一个没有参数的构造函数，此时创建对象就用默认生成的构造函数。如果你写了一个有参构造函数，那么编译器就不会给你无参构造，如果再用无参构造取创建对象，就会报错。同理，子继承父也是这样，一般都将无参构造写出来。

### 2.1.4. 成员变量与局部变量的区别有哪些？

成员变量：有默认值，对象销毁，值销毁，属于对象，能被访问修饰符和static、final 修饰，。

局部变量：无默认值，方法结束，值销毁，属于方法，不能被访问修饰符和static修饰。

### 2.1.5. 创建一个对象用什么运算符?对象实体与对象引用有何不同?

new ，对象实体是放在堆中的，对象引用是放在虚拟机栈中的。对象引用可以有多个，同时指向一个对象实体。

### 2.1.6. 一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?

创建类，可以，编译器会自动帮你创建一个默认没有参数的构造函数，你可以用这个构造函数来创建对象。

### 2.1.7. 构造方法有哪些特性？

无返回值（连void 都不可以有）

名字与类名相同

默认使用public

生成对象时，自动执行。无需调用

### 2.1.8. 在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?

有的成员属于父类，需要父类的构造函数进行初始化， 所以需要先调用父类的构造函数，帮助子类完成初始化工作。

### 2.1.9. 对象的相等与指向他们的引用相等,两者有什么不同?

对象相等，值得时他们在堆中有各自的数据，并且他们的数据是相同的。引用相同是指，堆中的数据只有一份，两个引用同时指向这个堆中地址。

### 2.2. 面向对象三大特征

### 2.2.1. 封装

就是将对象封装成一个盒子，只对外提供，如何创建，如何一些方法来对内部的数据进行操作。

### 2.2.2. 继承

对象之间有个共性的东西，我们把他抽象出来，让后让大家去继承这个类，就是共有的属性和方法。子类用于父类的属性和方法(只是拥有)，私有的属性和方法子类无法访问。

### 2.2.3. 多态

父类的引用指向子类对象，相同的代码产生不同的结果。

## 2.3. 修饰符

### 2.3.1. 在一个静态方法内调用一个非静态成员为什么是非法的?

静态方法是属于类的，非静态方法是属于对象的。

### 2.3.2. 静态方法和实例方法有何不同

静态方法是属于类的，通过对象和类名进行访问。

实例方法是属于对象的，通过对象进行访问。

### 2.3.3. 常见关键字总结:static,final,this,super

static：修饰属性、方法，属于类

final：修饰属性、方法、类，不可修改，不可重写、不可继承

this：指代当前对象，this（）指代当前的构造函数

super：指代父类对象，super（）指代父类的构造函数

## 2.4. 接口和抽象类

### 2.4.1. 接口和抽象类的区别是什么？

接口：没有构造函数，可以有属性public static final，可以有方法，方法体为空，默认修饰是public abstract

抽象类：可以有构造方法，可以有属性，可以有普通方法，也可以有抽象方法，抽象方法没有方法体。

## 2.5. 其它重要知识点

### 2.5.1. String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?

StringBuffer：线程安全，方法中都加了synchronized

StringBuilder：线程不安全

String：中用于存储的字符数组是private final char value[],是不可变的。而StringBuffer 和StringBuilder 继承自AbstractStringBuilder，中用于存储的字符数组是char [] value,是可变的。

### 2.5.2. Object 类的常见方法总结

hashCode()// 获取哈希码

equas()//对比对象内存地址

toString()// 类名@哈希码

wait() // 三次重载

notify()// 

notifyAll()

clone()// 复制对象

finalize()// 垃圾回收

### 2.5.3. == 与 equals(重要)

==：基本数据类型比的值，引用类型，比较的是地址

equals：Object 比较的是地址。一般自己实现，比较对象中的内容

### 2.5.4. hashCode 与 equals (重要)

重写过

```
public class Person
{
    private String name;

    private int age;

    private String sex;

    Person(String name,int age,String sex){
        this.name = name;
        this.age = age;
        this.sex = sex;
    }

    @Override public boolean equals(Object obj)
    {
        if(obj instanceof Person){
            Person person = (Person)obj;
            return name.equals(person.name);
        }
        return super.equals(obj);
    }

    @Override public int hashCode()
    {
        return name.hashCode();// 只专注要比较的字段的hashCode就行
    }
}
```

hashCode 主要减少对比的次数，如果单单实现equals ，equals 返回ture ，而hashCode 可能返回false ， 违背了hashCode 和equals 的原则（equals 相同用相同的hashCode）。

### 2.5.5. Java 序列化中如果有些字段不想进行序列化，怎么办？

使用 transient 关键字修饰，阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。transient 只能修饰变量，不能修饰类和方法。

### 2.5.6. 获取用键盘输入常用的两种方法

```
Scanner scanner = new Scanner(System.in);
String string = scanner.nextLine();
int i = scanner.nextInt();
```

```
BufferedReader bufferReader = new BufferedReader(new InputStreamReader(System.in));
String s = bufferReader.readLine();
```

# Java 核心技术

## 3.1. 集合

### 3.1.1. Collections 工具类和 Arrays 工具类常见方法总结

Collections:

reverse（List）

shffle（List）//随机排序

sort（List，Comparator）

swap（List，int，int)

rotate（List，int）

binarySearch（List,key）

max（Collection）

fill(List,Object)

frequency（List,List)

indexOfSubList(List,List)

replaceAll(List，oldVal，newVal)

同步方法不建议使用

Arrays:

sort()

binarySearch()

equals()

fill()

asList()

toString()

copyOf()

## 3.2. 异常

所有的异常都有一个共同的祖先java.lang 中的Throwable 类。Throwable 类 有两个重要的子类 Exception 和 Error。

### 3.2.1. Java 异常类层次结构图

Error：是程序无法处理的错误，大多数情况与编写的程序无关，而是java虚拟机出现了问题，例如OutOfMemoryError、VirtualMechineError、ThreadDeath。

Exception：程序本身可以处理异常,包括运行时异常和检查异常，检查异常有IOException、SQLException，运行时异常有空指针、数组下表越界、算数异常、类型转换异常。

### 3.2.2. Throwable 类常用方法

getMessage()

toString()

getLocalizedMessage()

printStackTrace()

### 3.2.3. try-catch-finally

try：负责捕获已成，一般只有一个

catch：负责处理异常，可以有多个

finally：一定执行，一般用于释放资源，有return，先将return 入栈，然后输出finally，最后返回执行return

### 3.2.4. 使用 try-with-resources 来代替try-catch-finally

try-catch-finally : 一般在 finally 中释放资源

try-with-resource：对于必须要关闭的资源，优先使用的操作。

```java
try (Scanner scanner = new Scanner(new File("test.txt"))) {
// 单个资源需要关闭
    while (scanner.hasNext()) {
        System.out.println(scanner.nextLine());
    }
} catch (FileNotFoundException fnfe) {
    fnfe.printStackTrace();
}
```

```
try (BufferedInputStream bin = new BufferedInputStream(new FileInputStream(new File("test.txt")));
             BufferedOutputStream bout = new BufferedOutputStream(new FileOutputStream(new File("out.txt")))) {
             // 多个资源需要关闭，使用分号分隔
            int b;
            while ((b = bin.read()) != -1) {
                bout.write(b);
            }
        }
        catch (IOException e) {
            e.printStackTrace();
        }
```

## 3.3. 多线程

### 3.3.1. 简述线程、程序、进程的基本概念。以及他们之间关系是什么?

线程：进程的更小单位，同类型的线程共享内存空间和资源。例如同时聊天和视频。

程序：含有指令和数据的文件，被存储在磁盘，程序是静态代码

进程：程序的一次执行过程，例如qq

### 3.3.2. 线程有哪些基本状态?

新建 new 线程被构建，但还是没有调用start（）

运行 runnable 运行状态，就绪和执行两种

阻塞 blocked

等待 waiting 需要其他线程给出通知notify（） 和notifyAll（）

超时等待 time_waiting  等待指定的时间，然后自行返回

结束 terminated 执行结束，线程结束

## 3.4. 文件与 I\O 流

### 3.4.1. Java 中 IO 流分为几种?

字符流：

BufferedReader

BufferdWriter

PipedReader

PipedWriter

FileReader

FileWriter

CharArrayReader

CharArrayWriter

StringReader

StringWriter

InputStreamReader

OutputStreamWriter

字节流：

BufferedInputStream

BufferedOutputStream

PipedInputStream

PipedOutputStream

FileInputStream

FileOutputStream

DataInputStream

DataInputStream

ObjectInputStream

ObjectOutputStream

ByteArrayInputStream

ByteArrayOutputStream

SequenceInputStream

SequenceOutputStream

### 3.4.1.1. 既然有了字节流,为什么还要有字符流?

字符流由java虚拟机转换得到，问题时非常耗时和不知道编码格式会报错，干脆就提供直接操作字符的接口，方便对字符进行操作，如果是音频文件使用字节流，如果涉及到字符的话使用字符流。

### 3.4.1.2. BIO,NIO,AIO 有什么区别?

BIO：适用于连接数目小且固定的架构。阻塞io，常用的字符流和字节流都是阻塞IO，必须等文件传输完成，才能继续线程，Socket 和ServerSocket 属于这种

NIO:适用于连接数目多且链接比较短的架构。非阻塞io，在java.nio中有提供，分别使用Buffer、channel、selector 等抽象。SocketChannel 和 Socket 属于这种。	

AIO：适用于连接数目多且连接比较长（重操作）的架构。是异步IO，是基于事件和回调机制实现的。

1. # 基础

  ## 1.1. 正确使用 equals 方法

str.equals(""),容易抛出空指针异常。

经常使用"".equals(str)。

推荐使用Objects.equals(str,"");

##   1.2. 整型包装类值的比较

自动装箱，范围在-127~128之间，创建Integer对象回缓存起来，当下次出现该数值的时候，直接从缓存取出对应的Integer对象。

##   1.3. BigDecimal

###   1.3.1. BigDecimal 的用处

用于处理精确的小数点位数，浮点数比较，基本不用==来比较，也不能使用equals来判断。会产生精度丢失，推荐使用BigDecimal 来定义浮点数的值。

###   1.3.2. BigDecimal 的大小比较

```
BigDecimal a = new BigDecimal("1.0");
BigDecimal b = new BigDecimal("2.0");
System.out.println(a.compareTo(b));// -1 表示小于，0表示等于，1表示大于
```

###   1.3.3. BigDecimal 保留几位小数

通过 setScale 方法设置保留几位小数，以及规则。

###   1.3.4. BigDecimal 的使用注意事项

为了防止精度丢失，我们使用BigDecimal（String） 构造方法或者使用BigDecimal.valueOf(double)来创建对象，而不是使用BigDecimal(double) 的方式。

2. # 集合

  ## 2.1. Arrays.asList()使用指南

  将数组转换为List 集合，返回的是java.util.Arrays 内部的一个静态类，而不是真正java.util.ArrayList，本身还是数组，如果进行add,remove,clear操作会报不支持操作异常。如果对数组进行改变，arr[0] = 1; 那么list.get(0) 也会跟着改变。

  ### 2.1.4. 如何正确的将数组转换为ArrayList?

  手动实现，for

  简便方法：new ArrayList(Arrays.asList('a','b'));

  Stream :

  ```
  Integer [] myArray = {1,2,3};
  List myList = Arrays.stream(myArray).collection(Collections.toList());
  ```

  Guava :

  ```
  List<String> il = ImmutableList.of("string", "elements");  // from varargs
  List<String> il = ImmutableList.copyOf(aStringArray);      // from array
  ```

  

  ## 2.2. Collection.toArray()方法使用的坑&如何反转数组

  

  ## 2.3. 不要在 foreach 循环里进行元素的 remove/add 操作

如果要进行remove 操作，可以使用迭代器的remove ，而不是集合类的remove，如果并发操作，需要对Iterator 对象加锁。如果通过集合类的remove/ add 方法进行，迭代器会抛出同时修改异常，这就是单线程下的fail-fast。

fail-fast ：是java集合的一种错误检测机制。多线程对fail-fast 集合进行修改时，可能会抛出同时修改异常，值得注意的时，单线程情况下， 如果操作不当，同时也可能抛出同时修改异常。java.util 包下面的所有集合都是fail-fast 的，而java.util.concurrent 包下面的所有类都是fail-safe 的。

foreach 遍历报异常的根本原因：ArrayList 中有成员变量modCount 还有一个内部类expectedModCount ,一个代表实际的修改次数，一个代表期望修改的次数。foreach 删除或者添加数据都是对modCount 进行修改，而没有对expectedModCount 进行修改，不想等，抛出异常。

## 2.4for循环中进行remove 操作，出现漏删的情况

for 循环是根据索引删除的，如果删除第一个值，那么list 会重新排序，所有的元素做位移操作，后面那个被删除的值会被挪到已经删除值得索引位置，就发生了漏删。

可以从后向前进行遍历，或者直接使用迭代器，使用Stream()，

### Servlet总结

Servlet 主要负责接受用户的请求，HttpServletRequest 使用Service（）方法，也就是doPost() 和doGet() 方法做出响应的处理。通过HttpServletResponse 对请求做出响应，Servlet 的生命周期有 init() service() destory() ,一个Servlet 类只有一个实例，Servlet 需要通过注解或者配置web.xml 文件，来实现对应的映射关系。一个Servlet 可以设置多个url 访问，Servlet 并不是线程安全的。

### 阐述Servlet和CGI的区别?

CGI的不足之处:

1，需要为每个请求启动一个操作CGI程序的系统进程。如果请求频繁，这将会带来很大的开销。

2，需要重复编写处理网络协议的代码以及编码。

Servlet的优点：

1，只需要启动一个操作系统进程以及加载一个JVM，大大降低了系统的开销

2，如果多个请求需要做同样处理的时候，这时候只需要加载一个类，这也大大降低了开销

3，所有动态加载的类可以实现对网络协议以及请求解码的共享。

4，Servlet能直接和Web服务器交互，而普通的CGI程序不能。

### Servlet接口中有哪些方法及Servlet生命周期探秘

init() 执行一次

service() 每次请求都会执行

destory() 执行一次

getServletInfo()

getServeltConfig()

### get和post请求的区别



什么情况下调用doGet()和doPost()
转发（Forward）和重定向（Redirect）的区别
自动刷新(Refresh)
Servlet与线程安全
JSP和Servlet是什么关系
JSP工作原理
JSP有哪些内置对象、作用分别是什么
Request对象的主要方法有哪些
request.getAttribute()和 request.getParameter()有何区别
include指令include的行为的区别
JSP九大内置对象，七大动作，三大指令
讲解JSP中的四种作用域
如何实现JSP或Servlet的单线程模式
实现会话跟踪的技术有哪些
Cookie和Session的的区别
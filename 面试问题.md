```bash
# 一级标题
## 二级标题
### 三级标题
#### 四级标题
##### 五级标题
###### 六级标题
```

```swift
//形式一
+ a
+ b
+ c
//形式二
- d
- e
- f
//形式三
* g
* h
* i
```

```cpp
//正常形式
1. abc
2. bcd
3. cde
//错序效果
2. fgh
3. ghi
5. hij
```

```cpp
//无序列表嵌套
+ 123
    + abc
    + bcd
    + cde
+ 465
+ 789
//有序列表嵌套
1. abcd
    1. abcde
    2. abcde
    3. abcde
2. bcde
3. cdef
```

```ruby
> 一级引用
>> 二级引用
>>> 三级引用
>>>> 四级引用
>>>>> 五级引用
>>>>>> 六级引用
```

~~~go
//大量代码    
```
        daliangdaima,xuyaoduohangshiyong
        daliangdaima,xuyaoduohangshiyong
        daliangdaima,xuyaoduohangshiyong
        daliangdaima,xuyaoduohangshiyong
        daliangdaima,xuyaoduohangshiyong
    ```
~~~

```undefined
//分割线
---
- - -
------
***
* * *
******
___
_ _ _
______
```

```undefined
//强调字体
*md*    
**md**
_md_   
 __md__
```

```undefined
\\
\*
\+
\-
\`
\_
```

```undefined
~~删除~~
```

---



### Java中的filter 的

#### 三个参数

ServletRequest

ServletResponse 

FilterChain

#### 生命周期

init

doFilter

destory

#### web.xml 配置

<filter>

<filter-name>

<filter-class>

<init-param>

<param-name>

<param-value>

<filter-mapping>

<filter-name>

<url-pattern>

#### 应用

编码格式的转换 和 登录过滤

---

### Maven

#### 作用

标准化的项目结构

标准化的构建流程

管理机制

#### pom.xml说明

groupId 公司或者组织的id

artifactId 项目名称

version 

dependency 依赖

parent 父项目

dependencies 项目依赖

dependency 具体的依赖

#### 生命周期

##### 标准生命周期

clean 项目的清理

default/build 项目的部署

site 项目站点文档创建处理

###### default/build 生命周期

validata 验证项目

compile

test

package

verify 检查

intall 安装，将打包的项目安装到本地

deploy 部署，拷贝工程到远程仓库有

###### clean 的生命周期

pre-clean

clean

post-clean

###### site 生命周期

pre-site

site

post-site

site-deploy

---

### Vue

使用基于 HTML 的模板语法，声明式的将 DOM 绑定到 Vue 实例数据

#### 安装

npm install 安装依赖

npm run dev 运行程序

#### 语句

v-if 条件判断

v-else else 块

v-else-if else if 块

v-for 条件循环,如果是键值对，可使用多个参数，例如v-for="(value,key) in object"

#### 属性

计算属性 computed 只有在依赖改变时，才会重新取值

监听属性 watch 用于响应数据的变化

data 的数据，变量不用引号，在 main 中是属性，在组件中是函数，好处是每个实例维护一份被返回对象的独立拷贝

#### 指令

v-html 绑定 data 中的变量，用于输出 html 代码

v-bind/: 双向绑定 data 中的变量，也可以绑定 style 和 class，例如v-bind:class=""

v-model 单向绑定 data 中的变量，表单实现双向绑定	

v-show 根据条件来展示元素

v-on/@ 对于事件的处理，例如v-on:keyup.enter=""

#### 组件

vue 组件 封装可用的代码，全局和局部组件，父组件通过 props 把数据传给子组件，子组件通过 $on 监听事件和 $emit 触发事件，传回给父组件

#### 路由

下载 npm run vue-router

##### router-link

to 当被电击是会立即把 to 的值传到 router.push(),这个值可以是一个字符串或者是描述目标位置的对象

replace 调用的是 rourer.replace() 导航后不会留下 history 记录

append 追加路径属性

tag <router-link>想要渲染成某种标签

acitve-class 链接激活时使用的 CSS 类名

event  用来触发导航事件

---



#### 后端生成文档

1. 使用AdobeAcrobatpro，设计pdf文档模板
2. 获取模板文档路径
3. HttpServletResponse 设置头，content-type 设置为 Application/pdf
4. 读取模板，对象PdfReader
5. 转换成字节流
6. 创建可操作的 pdf 模板对象，PdfStamper
7. 封装数据，AcoFields
8. 填充数据
9. 设置是否可修改
10. 关闭资源

---

### JPA

创建表

自动实现保存和删除

#### JPA Hibernate 关系

JPA 是一种规范，不是框架

Hibernate 是JPA的一种实现，是框架

#### 注解

@Entity

@Table

@Id

@GenterateValue 指定如何标识属性可以被初始化

@Transient

@Column

@TableGenerator

#### 定义JPA接口

public interface XXRepository extends JpaRepository<XX,String>{}

#### JPA关键字

And

Or

Is/Equals

Between

LessThan

LessThanEqual

GreaterThan

GreaterThanEqual

After

Before

IsNull

Like

NotLike

OrderBy

### MyBatis

#### 什么是mybatis

MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。

#### 功能框架

1. API接口层：提供给外部使用的接口API，开发人员通过这些本地API来操纵数据库。接口层一接收到调用请求就会调用数据处理层来完成具体的数据处理。
2. 数据处理层：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的目的是根据调用的请求完成一次数据库操作。
3. 基础支撑层：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑。

#### 优点

- 简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。
- 灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。 sql写在xml里，便于统一管理和优化。通过sql基本上可以实现我们不使用数据访问框架可以实现的所有功能，或许更多。
- 解除sql与程序代码的耦合：通过提供DAL层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。
- 提供映射标签，支持对象与数据库的orm字段关系映射
- 提供对象关系映射标签，支持对象关系组建维护
- 提供xml标签，支持编写动态sql。

#### 缺点

- 编写SQL语句时工作量很大，尤其是字段多、关联表多时，更是如此。
- SQL语句依赖于数据库，导致数据库移植性差，不能更换数据库。
- 框架还是比较简陋，功能尚有缺失，虽然简化了数据绑定代码，但是整个底层数据库查询实际还是要自己写的，工作量也比较大，而且不太容易适应快速数据库修改。
- 二级缓存机制不佳

#### xml配置

MyBatis 的配置文件包含了影响 MyBatis 行为甚深的设置（settings）和属性（properties）信息。

##### properties

这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。

<properties resource="org/mybatis/example/config.properties">  

<property name="username" value="dev_user"/>  

<property name="password" value="F2Fa3!33TYyg"/> 

</properties>

如果属性在不只一个地方进行了配置，那么 MyBatis 将按照下面的顺序来加载：

因此，通过方法参数传递的属性具有最高优先级，resource/url 属性中指定的配置文件次之，最低优先级的是 properties 属性中指定的属性。

##### settings

这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。下表描述了设置中各项的意图、默认值等。

<settings>   

<setting name="cacheEnabled" value="true"/>   

<setting name="lazyLoadingEnabled" value="true"/>   

<setting name="multipleResultSetsEnabled" value="true"/>   

<setting name="useColumnLabel" value="true"/>   

<setting name="useGeneratedKeys" value="false"/>   

<setting name="autoMappingBehavior" value="PARTIAL"/>   

<setting name="defaultExecutorType" value="SIMPLE"/>   

<setting name="defaultStatementTimeout" value="25"/>   

<setting name="safeRowBoundsEnabled" value="false"/>   

<setting name="mapUnderscoreToCamelCase" value="false"/>   

<setting name="localCacheScope" value="SESSION"/>   

<setting name="jdbcTypeForNull" value="OTHER"/>   

<setting name="lazyLoadTriggerMethods" value="equals,clone,hashCode,toString"/> 

</settings>

##### typeAliases

类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。

<typeAliases>   

<typeAlias alias="Author" type="domain.blog.Author"/>   

<typeAlias alias="Blog" type="domain.blog.Blog"/>   

<typeAlias alias="Comment" type="domain.blog.Comment"/>   

<typeAlias alias="Post" type="domain.blog.Post"/>   

<typeAlias alias="Section" type="domain.blog.Section"/>   

<typeAlias alias="Tag" type="domain.blog.Tag"/> 

</typeAliases>//为全限定名设置一个短的名字

<typeAliases>  <package name="domain.blog"/> </typeAliases> // 配置包名

@Alias("author") //注解方式

##### typeHandlers

无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。 具体做法为：实现 `org.apache.ibatis.type.TypeHandler` 接口， 或继承一个很便利的类 `org.apache.ibatis.type.BaseTypeHandler`， 然后可以选择性地将它映射到一个 JDBC 类型。

<typeHandlers>  

<typeHandler handler="org.mybatis.example.ExampleTypeHandler"/> 

</typeHandlers>

##### 处理枚举类型

若想映射枚举类型 `Enum`，则需要从 `EnumTypeHandler` 或者 `EnumOrdinalTypeHandler` 中选一个来使用。

比如说我们想存储取近似值时用到的舍入模式。默认情况下，MyBatis 会利用 `EnumTypeHandler` 来把 `Enum` 值转换成对应的名字。

注意 `EnumTypeHandler` 在某种意义上来说是比较特别的，其他的处理器只针对某个特定的类，而它不同，它会处理任意继承了 `Enum` 的类。

使用 Mapper 接口，并不对接口进行实现，底层使用动态代理来实现，接口的全限定名就是 namespace 的值，当调用接口方法时，全限定名+方法名拼接成的 key 对应的一个唯一的 MappedStatement 

##### 配置环境

MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中， 现实情况下有多种理由需要这么做。例如，开发、测试和生产环境需要有不同的配置；或者共享相同 Schema 的多个生产数据库， 想使用相同的 SQL 映射。许多类似的用例。

不过要记住：尽管可以配置多个环境，每个 SqlSessionFactory 实例只能选择其一。

所以，如果你想连接两个数据库，就需要创建两个 SqlSessionFactory 实例，每个数据库对应一个。而如果是三个数据库，就需要三个实例，依此类推。

<environments default="development">   

<environment id="development">     

<transactionManager type="JDBC">       

<property name="..." value="..."/>     

</transactionManager>     

<dataSource type="POOLED">       

<property name="driver" value="${driver}"/>       

<property name="url" value="${url}"/>       

<property name="username" value="${username}"/>       

<property name="password" value="${password}"/>     

</dataSource>   

</environment> 

</environments>

##### 事务

<transactionManager type="MANAGED">  <property name="closeConnection" value="false"/> </transactionManager>

##### 数据源

###### UNPOLLED

这个数据源的实现只是每次被请求时打开和关闭连接。虽然一点慢，它对在及时可用连接方面没有性能要求的简单应用程序是一个很好的选择。 不同的数据库在这方面表现也是不一样的，所以对某些数据库来说使用连接池并不重要，这个配置也是理想的。

- `driver` – 这是 JDBC 驱动的 Java 类的完全限定名（并不是JDBC驱动中可能包含的数据源类）。
- `url` – 这是数据库的 JDBC URL 地址。
- `username` – 登录数据库的用户名。
- `password` – 登录数据库的密码。
- `defaultTransactionIsolationLevel` – 默认的连接事务隔离级别。

###### POLLED

这种数据源的实现利用"池"的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。 这是一种使得并发 Web 应用快速响应请求的流行处理方式。

- `poolMaximumActiveConnections` – 在任意时间可以存在的活动（也就是正在使用）连接数量，默认值：10
- `poolMaximumIdleConnections` – 任意时间可能存在的空闲连接数。
- `poolMaximumCheckoutTime` – 在被强制返回之前，池中连接被检出（checked out）时间，默认值：20000 毫秒（即 20 秒）
- `poolTimeToWait` – 这是一个底层设置，如果获取连接花费的相当长的时间，它会给连接池打印状态日志并重新尝试获取一个连接（避免在误配置的情况下一直安静的失败），默认值：20000 毫秒（即 20 秒）。
- `poolPingQuery` – 发送到数据库的侦测查询，用来检验连接是否处在正常工作秩序中并准备接受请求。默认是"NO PING QUERY SET"，这会导致多数数据库驱动失败时带有一个恰当的错误消息。
- `poolPingEnabled` – 是否启用侦测查询。若开启，也必须使用一个可执行的 SQL 语句设置 `poolPingQuery` 属性（最好是一个非常快的 SQL），默认值：false。
- `poolPingConnectionsNotUsedFor` – 配置 poolPingQuery 的使用频度。这可以被设置成匹配具体的数据库连接超时时间，来避免不必要的侦测，默认值：0（即所有连接每一时刻都被侦测 — 当然仅当 poolPingEnabled 为 true 时适用）。

###### JNDI

这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。

- `initial_context` – 这个属性用来在 InitialContext 中寻找上下文（即，initialContext.lookup(initial_context)）。这是个可选属性，如果忽略，那么 data_source 属性将会直接从 InitialContext 中寻找。
- `data_source` – 这是引用数据源实例位置的上下文的路径。提供了 initial_context 配置时会在其返回的上下文中进行查找，没有提供时则直接在 InitialContext 中查找。

##### 映射器

既然 MyBatis 的行为已经由上述元素配置完了，我们现在就要定义 SQL 映射语句了。但是首先我们需要告诉 MyBatis 到哪里去找到这些语句。 Java 在自动查找这方面没有提供一个很好的方法，所以最佳的方式是告诉 MyBatis 到哪里去找映射文件。你可以使用相对于类路径的资源引用， 或完全限定资源定位符（包括 `file:///` 的 URL），或类名和包名等。

<mappers>  <mapper resource="org/mybatis/builder/AuthorMapper.xml"/>  

<mapper resource="org/mybatis/builder/BlogMapper.xml"/>  

<mapper resource="org/mybatis/builder/PostMapper.xml"/> 

</mappers>

#### 映射文件

##### select

```
<select id="selectPerson" parameterType="int" resultType="hashmap">  SELECT * FROM PERSON WHERE ID = #{id} </select>    
<select #常用参数
  id="selectPerson"
  parameterType="int"
  parameterMap="deprecated"
  resultType="hashmap"
  resultMap="personResultMap"
  flushCache="false"
  useCache="true"
  timeout="10000"
  fetchSize="256"
  statementType="PREPARED"
  resultSetType="FORWARD_ONLY"> 
```



##### insert updata delete

```
<insert  id="insertAuthor"  parameterType="domain.blog.Author"  flushCache="true"  statementType="PREPARED"  keyProperty=""  keyColumn=""  useGeneratedKeys=""  timeout="20"> 
<update  id="updateAuthor"  parameterType="domain.blog.Author"  flushCache="true"  statementType="PREPARED"  timeout="20"> 
<delete  id="deleteAuthor"  parameterType="domain.blog.Author"  flushCache="true"  statementType="PREPARED"  timeout="20">
```

##### sql

这个元素可以被用来定义可重用的 SQL 代码段，可以包含在其他语句中。

<sql id="userColumns"> ${alias}.id,${alias}.username,${alias}.password </sql>

##### 参数

```
<select id="selectUsers" resultType="User">
  select id, username, password
  from users
  where id = #{id}
</select>
```

##### 字符串替换

${}这种方式接受从用户输出的内容并提供给语句中不变的字符串是不安全的，会导致潜在的 SQL 注入攻击，因此要么不允许用户输入这些字段，要么自行转义并检验。

##### ResultsMap （一张表中）

```
<!-- In mybatis-config.xml file --> 

<typeAlias type="com.someapp.model.User" alias="User"/> 

<!-- In SQL Mapping XML file --> 
<select id="selectUsers" resultType="User">  select id, username, hashedPassword  from some_table  where id = #{id} </select>
```

##### 高级结果映射 （多张表中）

<!-- Very Complex Statement --> 

```
<select id="selectBlogDetails" resultMap="detailedBlogResultMap">  
select       B.id as blog_id,       B.title as blog_title,       B.author_id as blog_author_id,       A.id as author_id,       A.username as author_username,       A.password as author_password,       A.email as author_email,       A.bio as author_bio,       A.favourite_section as author_favourite_section,       P.id as post_id,       P.blog_id as post_blog_id,       P.author_id as post_author_id,       P.created_on as post_created_on,       P.section as post_section,       P.subject as post_subject,       P.draft as draft,       P.body as post_body,       C.id as comment_id,       C.post_id as comment_post_id,       C.name as comment_name,       C.comment as comment_text,       T.id as tag_id,       T.name as tag_name  from Blog B       
left outer join Author A on B.author_id = A.id       
left outer join Post P on B.id = P.blog_id       
left outer join Comment C on P.id = C.post_id       
left outer join Post_Tag PT on PT.post_id = P.id       
left outer join Tag T on PT.tag_id = T.id  where B.id = #{id} 
</select>
```



#### 动态sql

###### if

```
<select id="findActiveBlogWithTitleLike"     resultType="Blog">  
SELECT * FROM BLOG   WHERE state = ‘ACTIVE’   
<if test="title != null">    
AND title like #{title}  
</if> 
</select>
```

##### choose when otherwise (Java 的 switch 语句，choose 为 switch，when 为 case，otherwise 则为 default。)

```
<select id="findActiveBlogLike"
     resultType="Blog">
  SELECT * FROM BLOG WHERE state = ‘ACTIVE’
  <choose>
    <when test="title != null">
      AND title like #{title}
    </when>
    <when test="author != null and author.name != null">
      AND author_name like #{author.name}
    </when>
    <otherwise>
      AND featured = 1
    </otherwise>
  </choose>
</select>
```

##### trim where set

where 会帮你自动修剪条件

```
<select id="findActiveBlogLike"
     resultType="Blog">
  SELECT * FROM BLOG 
  <where> 
    <if test="state != null">
         state = #{state}
    </if> 
    <if test="title != null">
        AND title like #{title}
    </if>
    <if test="author != null and author.name != null">
        AND author_name like #{author.name}
    </if>
  </where>
</select>
<trim prefix="WHERE" prefixOverrides="AND |OR ">  ...  </trim> 
```

set 元素可以被用于动态包含需要更新的列

```
<update id="updateAuthorIfNecessary">
  update Author
    <set>
      <if test="username != null">username=#{username},</if>
      <if test="password != null">password=#{password},</if>
      <if test="email != null">email=#{email},</if>
      <if test="bio != null">bio=#{bio}</if>
    </set>
  where id=#{id}
</update>
```

##### foreach

动态 SQL 的另外一个常用的必要操作是需要对一个集合进行遍历

```
<select id="selectPostIn" resultType="domain.blog.Post">
  SELECT *
  FROM POST P
  WHERE ID in
  <foreach item="item" index="index" collection="list"
      open="(" separator="," close=")">
        #{item}
  </foreach>
</select>
```

#### 目录结构

```
/my_application
  /bin
  /devlib
  /lib                <-- MyBatis *.jar文件在这里。
  /src
    /org/myapp/
      /action
      /data           <-- MyBatis配置文件在这里, 包括映射器类, XML配置, XML映射文件。
        /mybatis-config.xml
        /BlogMapper.java
        /BlogMapper.xml
      /model
      /service
      /view
    /properties       <-- 在你XML中配置的属性 文件在这里。
  /test
    /org/myapp/
      /action
      /data
      /model
      /service
      /view
    /properties
  /web
    /WEB-INF
      /web.xml
```



### 树形结构的



### 存储

设置一个 superId ,当数据是第一级树的时候，设置为空，通过一级查找二级，依次下去。

### 常用的Utils

OSUtils 负责不同的操作系统，路径的选择

TreeUtils 树形结构utils

BeanUtils 负责bean的操作

### JsonResponse

对返回值的封装，通过code 说明状态码，通过msg说明返回的信息，还有一个泛型的data,返回响应数据。

构造方法有JsonResponse()

JsonResponse( code,message);

JsonResponse(code,message,data)

静态方法success() , 返回一个code 为0，msg为空的JsonResponse 对象

静态方法success(T data),返回一个code 为0，msg为空的，值为data的JsonResponse 对象

静态方法success(String message,T data)，返回一个code为0，message ，数据是data的JsonResponse() 方法

静态方法fail(String message),返回状态码为1， message信息

静态方法fail(int code，String message)，返回状态为code，messge信息

### 用户权限控制



### 文件的导入导出

### docker



### Java基础

#### Java 中为什么只有值传递

java 中的对象采用的不是应用调用，而是值传递

#### hashCode()  和 equals

Object 中实现了 hashCode() ，hashCode() 是两个对象equals 前的操作，haCode() 的计算方法一般通过一个质数的乘法完成，比如String 的hashCode 是通过31*hash+string[i]，每个字符串有一个特定的hash，如果hash相同，他们可能equals，如果他们equals，那么他们的hash一定相同。hashCode 可以大大减小数据的之间的对比次数，如果比较两个string 是否equals 那么正常的思路就是一个个比，这样效率太差，可通过 hashCode 来先预判一下，两个string是否相等，提高效率，缩小查找的成本。两个 hashCode 值相等，这种叫 hash 冲突。

#### String StringBuilder StringBuffer

String 对象都是用 final 修饰的，内容不可变，但是指向是可以改变的

StringBuilder 是线程不安全的，通过apped 可以追加string 

StringBuffer 是线程安全的，通过append 可以追加string，所有的方法都是加了synchronized 的

#### 反射机制



---



# 1.1. Java 入门（基础概念与常识）

## 1.1.1. Java 语言有哪些特点

简单易学、支持面向对象、支持一次编译多平台使用、支持多线程、支持网络编程、取消了指针的使用，取消了多继承

可靠安全

## 1.1.2. 关于 JVM JDK 和 JRE 最详细通俗的解答

### 1.1.2.1. JVM

java virtual machine， 负责加载.class 文件，不同的系统有不同的实现。一次编译，随处执行

### 1.1.2.2. JDK 和 JRE

JDK：是java development kit ， 包含了运行时环境、编译、还有常用的基础包，如果要编写代码推荐用这个。

JRE：是java runtime environment ， 只是包含了运行时环境，如果要跑已经编译好的.class 文件可以胜任。

## 1.1.3. Oracle JDK 和 OpenJDK 的对比

Open JDK 由sun公司开放源码，由Oracle 工程师维护

## 1.1.4. Java 和 C++的区别

c++ ：带指针，支持多继承，无内存管理（手动释放）,字符串以\0结束

java：不带指针，不支持多继承，支持单继承，实现多接口，有内存管理（自动释放），java 没有结束这个概念

## 1.1.5. 什么是 Java 程序的主类 应用程序和小程序的主类有何不同

public static void main(String[] args){} ，只能有一个，不一定是public

java 小程序中，继承JApplet 和 Applet  的子类 ，必须是public

## 1.1.6. Java 应用程序与小程序之间有哪些差别

应用程序的主线程是main（）方法，小程序没有main，主要是浏览器运行init（） 和run（） 来启动

### 1.1.7. import java 和 javax 有什么区别

java 和 javax 本质上是与java 编程语言的上下文一起使用的包，api 所必须的包是Java， javax 包含java 的扩展。javax 为标注api的一部分。实际上没有区别，都是一个名字。

### 1.1.8. 为什么说 Java 语言编译与解释并存

有编译语言的特征，也有解释语言的特征。先经过编译，编译成.class 文件，然后字节码文件由java 解释器来解释执行。就像一本英文的书，先翻译成中文，然后再去阅读。

# 1.2. Java 语法

## 1.2.1. 字符型常量和字符串常量的区别

字符型是单引号，只占两个字节，相当于一个整型值

字符串是双引号，占据若干个字节，相当于一个地址（指向内存中存放的位置）

### 1.2.2. 关于注释

单行注释 // 

多行/*  */

### 1.2.3. 标识符和关键字的区别是什么

标识符：字母、数字、下划线、$, 不以数字开头

关键字：变量修饰符、程序控制、错误处理、包相关

### 1.2.4. Java中有哪些常见的关键字

|                      |          |            |          |              |            |           |        |
| -------------------- | -------- | ---------- | -------- | ------------ | ---------- | --------- | ------ |
| 访问控制             | private  | protected  | public   |              |            |           |        |
| 类，方法和变量修饰符 | abstract | class      | extends  | final        | implements | interface | native |
|                      | new      | static     | strictfp | synchronized | transient  | volatile  |        |
| 程序控制             | break    | continue   | return   | do           | while      | if        | else   |
|                      | for      | instanceof | switch   | case         | default    |           |        |
| 错误处理             | try      | catch      | throw    | throws       | finally    |           |        |
| 包相关               | import   | package    |          |              |            |           |        |
| 基本类型             | boolean  | byte       | char     | double       | float      | int       | long   |
|                      | short    | null       | true     | false        |            |           |        |
| 变量引用             | super    | this       | void     |              |            |           |        |
| 保留字               | goto     | const      |          |              |            |           |        |

### 1.2.5. 自增自减运算符

i++  i--;

### 1.2.6. continue、break、和return的区别是什么

continue 结束本次循环

break 跳出循环体

return 结束方法的运行

### 1.2.7. Java泛型了解么？什么是类型擦除？介绍一下常用的通配符

泛型：常用于集合，就是不确定数据类型，使用T 真能代替对象类型，可以让代码的灵活性和复用性得以增强，本质是参数化类型

java 中的泛型是伪泛型，java编译期间，所有的泛型信息会被擦除，这也就是所说的类型擦除，如果没有指定具体的类型，会按照Object 类型进行处理

通配符：

？ 表示不确定的 java 类型

T (type) 表示具体的一个java类型

K V (key value) 分别代表java键值中的Key Value

E (element) 代表Element

- T 只有extends一种限定方式，<T extends List>是合法的，<T super List>是不合法的
- ？有extends与super两种限定方式，即<? extends List> 与<? super List>都是合法的
- T 用于泛型类和泛型方法的定义。？用于泛型方法的调用和形参
- 对于 ？super （下界）的通配符限定泛型，我们可以读取其中的元素，但读取出来的元素会变为 Object 类型。
- 对于 ？ extends (上界)的通配符限定泛型，我们无法向里面添加元素(只可以添加null)，只能读取其中的元素。

序列化一个泛型类，然后反序列化，丧失原有的类型信息。

### 1.2.8. ==和equals的区别

Object 中的 equals 就是比较的内存地址，好多类都会重写equals（），来实现内容的比较。

而平常我们用的== 就是比较的内存地址，基本数据类型，比较时就是比较的值，而对象类型比较时，比较的是内存地址

### 1.2.9. hashCode()与 equals()

hashCode（） 从Object 中就实现了 ，是一个本地方法，一般返回一个对象的哈希码（是一个整数），减少equals 的次数。

equals（）在Object 中也有实现，他比较的是内存地址。String 类中比较的是String 的内容。

重写equals（） 时，必须重写hashCode()，字符串堆hash 进行加功31*hash+val[i]，先比较类型，和内存值，如果相等返回true，不相等分别将String 转换为 array， 然后一次比较。

hashCode 相等，equals 可能不相等；hashCode不相等，equals 一定不相等。

## 1.3. 基本数据类型

### 1.3.1. Java中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？

就是基本类型和引用类型

byte-Byte-1

short-Short-2

int -Integer-4

long-Long-8

boolean-Boolean-1

char-Charecter-2

float-Floa-4

double-Double-8



### 1.3.2. 自动装箱与拆箱

装箱：就是将基本类型转化为包装类型，Integer i= 5；,通过valueOf实现

拆箱：就是将包装类型转化为基本类型	int a = i;，通过intValue实现

### 1.3.3. 8种基本类型的包装类和常量池

常量池技术，就是在池中缓存一些数据，Byte，Short，Integer，Long，面四种包装类型都默认创建【-128,127】 的相应的缓存数据;Character 默认创建【0，127】范围的缓存数据。Boolean 直接返回 true 和 false。如果超出范围，会返回一个新的对象。（这些都是通过valueOf 方法实现的。

## 1.4. 方法（函数）

### 1.4.1. 什么是方法的返回值?返回值在类的方法里的作用是什么?

返回值，就是通过return 返回的值，可以指定为基本数据类型和对象类型。作用时返回一个结果。

### 1.4.2. 为什么 Java 中只有值传递？

是的，方法中的形参值，是实参的一个拷贝，如果是基本数据类型，那就拷贝是原来的值，如果是引用类型，那么拷贝的是引用的值（也就是地址）。形参属于局部变量，在函数结束的时候，会释放。如果通过引用类型对数据进行修改，那么原来指向的数据也会改变，比如对象和数组。

### 1.4.3. 重载和重写的区别 

重载：根据不同的参数输入，做不同的处理。参数必须不同，返回值类型可以不同，异常可以不同，访问修饰符可以不同，编译期间。

重写：是子类继承父类的相同方法，相同的代码，做出不同的反应。返回值、方法名、参数列表必须相同，异常小于等于父，访问权限大于等于父，运行期间。

### 1.4.4. 深拷贝 vs 浅拷贝

深拷贝：不光拷贝引用类型，同时引用的数据也要拷贝一份。

浅拷贝：只是拷贝引用类型。

# Java 面向对象

## 2.1. 类和对象

### 2.1.1. 面向对象和面向过程的区别

面向对象：性能差，易维护，易扩展，易复用。

面向过程：性能好，不易维护，不易扩展，不易复用。

### 2.1.2. 构造器 Constructor 是否可被 override?

可以，对不同的数据，给出不同的处理。

### 2.1.3. 在 Java 中定义一个不做事且没有参数的构造方法的作用

如果你不写构造函数的话，jvm会自动帮你生成一个没有参数的构造函数，此时创建对象就用默认生成的构造函数。如果你写了一个有参构造函数，那么编译器就不会给你无参构造，如果再用无参构造取创建对象，就会报错。同理，子继承父也是这样，一般都将无参构造写出来。

### 2.1.4. 成员变量与局部变量的区别有哪些？

成员变量：有默认值，对象销毁，值销毁，属于对象，能被访问修饰符和static、final 修饰，。

局部变量：无默认值，方法结束，值销毁，属于方法，不能被访问修饰符和static修饰。

### 2.1.5. 创建一个对象用什么运算符?对象实体与对象引用有何不同?

new ，对象实体是放在堆中的，对象引用是放在虚拟机栈中的。对象引用可以有多个，同时指向一个对象实体。

### 2.1.6. 一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?

创建类，可以，编译器会自动帮你创建一个默认没有参数的构造函数，你可以用这个构造函数来创建对象。

### 2.1.7. 构造方法有哪些特性？

无返回值（连void 都不可以有）

名字与类名相同

默认使用public

生成对象时，自动执行。无需调用

### 2.1.8. 在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?

有的成员属于父类，需要父类的构造函数进行初始化， 所以需要先调用父类的构造函数，帮助子类完成初始化工作。

### 2.1.9. 对象的相等与指向他们的引用相等,两者有什么不同?

对象相等，值得时他们在堆中有各自的数据，并且他们的数据是相同的。引用相同是指，堆中的数据只有一份，两个引用同时指向这个堆中地址。

### 2.2. 面向对象三大特征

### 2.2.1. 封装

就是将对象封装成一个盒子，只对外提供，如何创建，如何一些方法来对内部的数据进行操作。

### 2.2.2. 继承

对象之间有个共性的东西，我们把他抽象出来，让后让大家去继承这个类，就是共有的属性和方法。子类用于父类的属性和方法(只是拥有)，私有的属性和方法子类无法访问。

### 2.2.3. 多态

父类的引用指向子类对象，相同的代码产生不同的结果。

## 2.3. 修饰符

### 2.3.1. 在一个静态方法内调用一个非静态成员为什么是非法的?

静态方法是属于类的，非静态方法是属于对象的。

### 2.3.2. 静态方法和实例方法有何不同

静态方法是属于类的，通过对象和类名进行访问。

实例方法是属于对象的，通过对象进行访问。

### 2.3.3. 常见关键字总结:static,final,this,super

static：修饰属性、方法，属于类

final：修饰属性、方法、类，不可修改，不可重写、不可继承

this：指代当前对象，this（）指代当前的构造函数

super：指代父类对象，super（）指代父类的构造函数

## 2.4. 接口和抽象类

### 2.4.1. 接口和抽象类的区别是什么？

接口：没有构造函数，可以有属性public static final，可以有方法，方法体为空，默认修饰是public abstract

抽象类：可以有构造方法，可以有属性，可以有普通方法，也可以有抽象方法，抽象方法没有方法体。

## 2.5. 其它重要知识点

### 2.5.1. String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?

StringBuffer：线程安全，方法中都加了synchronized

StringBuilder：线程不安全

String：中用于存储的字符数组是private final char value[],是不可变的。而StringBuffer 和StringBuilder 继承自AbstractStringBuilder，中用于存储的字符数组是char [] value,是可变的。

### 2.5.2. Object 类的常见方法总结

hashCode()// 获取哈希码

equas()//对比对象内存地址

toString()// 类名@哈希码

wait() // 三次重载

notify()// 

notifyAll()

clone()// 复制对象

finalize()// 垃圾回收

### 2.5.3. == 与 equals(重要)

==：基本数据类型比的值，引用类型，比较的是地址

equals：Object 比较的是地址。一般自己实现，比较对象中的内容

### 2.5.4. hashCode 与 equals (重要)

重写过

```
public class Person
{
    private String name;

    private int age;

    private String sex;

    Person(String name,int age,String sex){
        this.name = name;
        this.age = age;
        this.sex = sex;
    }

    @Override public boolean equals(Object obj)
    {
        if(obj instanceof Person){
            Person person = (Person)obj;
            return name.equals(person.name);
        }
        return super.equals(obj);
    }

    @Override public int hashCode()
    {
        return name.hashCode();// 只专注要比较的字段的hashCode就行
    }
}
```

hashCode 主要减少对比的次数，如果单单实现equals ，equals 返回ture ，而hashCode 可能返回false ， 违背了hashCode 和equals 的原则（equals 相同用相同的hashCode）。

### 2.5.5. Java 序列化中如果有些字段不想进行序列化，怎么办？

使用 transient 关键字修饰，阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。transient 只能修饰变量，不能修饰类和方法。

### 2.5.6. 获取用键盘输入常用的两种方法

```
Scanner scanner = new Scanner(System.in);
String string = scanner.nextLine();
int i = scanner.nextInt();
```

```
BufferedReader bufferReader = new BufferedReader(new InputStreamReader(System.in));
String s = bufferReader.readLine();
```

# Java 核心技术

## 3.1. 集合

### 3.1.1. Collections 工具类和 Arrays 工具类常见方法总结

Collections:

reverse（List）

shffle（List）//随机排序

sort（List，Comparator）

swap（List，int，int)

rotate（List，int）

binarySearch（List,key）

max（Collection）

fill(List,Object)

frequency（List,List)

indexOfSubList(List,List)

replaceAll(List，oldVal，newVal)

同步方法不建议使用

Arrays:

sort()

binarySearch()

equals()

fill()

asList()

toString()

copyOf()

## 3.2. 异常

所有的异常都有一个共同的祖先java.lang 中的Throwable 类。Throwable 类 有两个重要的子类 Exception 和 Error。

### 3.2.1. Java 异常类层次结构图

Error：是程序无法处理的错误，大多数情况与编写的程序无关，而是java虚拟机出现了问题，例如OutOfMemoryError、VirtualMechineError、ThreadDeath。

Exception：程序本身可以处理异常,包括运行时异常和检查异常，检查异常有IOException、SQLException，运行时异常有空指针、数组下表越界、算数异常、类型转换异常。

### 3.2.2. Throwable 类常用方法

getMessage()

toString()

getLocalizedMessage()

printStackTrace()

### 3.2.3. try-catch-finally

try：负责捕获已成，一般只有一个

catch：负责处理异常，可以有多个

finally：一定执行，一般用于释放资源，有return，先将return 入栈，然后输出finally，最后返回执行return

### 3.2.4. 使用 try-with-resources 来代替try-catch-finally

try-catch-finally : 一般在 finally 中释放资源

try-with-resource：对于必须要关闭的资源，优先使用的操作。

```java
try (Scanner scanner = new Scanner(new File("test.txt"))) {
// 单个资源需要关闭
    while (scanner.hasNext()) {
        System.out.println(scanner.nextLine());
    }
} catch (FileNotFoundException fnfe) {
    fnfe.printStackTrace();
}
```

```
try (BufferedInputStream bin = new BufferedInputStream(new FileInputStream(new File("test.txt")));
             BufferedOutputStream bout = new BufferedOutputStream(new FileOutputStream(new File("out.txt")))) {
             // 多个资源需要关闭，使用分号分隔
            int b;
            while ((b = bin.read()) != -1) {
                bout.write(b);
            }
        }
        catch (IOException e) {
            e.printStackTrace();
        }
```

## 3.3. 多线程

### 3.3.1. 简述线程、程序、进程的基本概念。以及他们之间关系是什么?

线程：进程的更小单位，同类型的线程共享内存空间和资源。例如同时聊天和视频。

程序：含有指令和数据的文件，被存储在磁盘，程序是静态代码

进程：程序的一次执行过程，例如qq

### 3.3.2. 线程有哪些基本状态?

新建 new 线程被构建，但还是没有调用start（）

运行 runnable 运行状态，就绪和执行两种

阻塞 blocked

等待 waiting 需要其他线程给出通知notify（） 和notifyAll（）

超时等待 time_waiting  等待指定的时间，然后自行返回

结束 terminated 执行结束，线程结束

## 3.4. 文件与 I\O 流

### 3.4.1. Java 中 IO 流分为几种?

字符流：

BufferedReader

BufferdWriter

PipedReader

PipedWriter

FileReader

FileWriter

CharArrayReader

CharArrayWriter

StringReader

StringWriter

InputStreamReader

OutputStreamWriter

字节流：

BufferedInputStream

BufferedOutputStream

PipedInputStream

PipedOutputStream

FileInputStream

FileOutputStream

DataInputStream

DataInputStream

ObjectInputStream

ObjectOutputStream

ByteArrayInputStream

ByteArrayOutputStream

SequenceInputStream

SequenceOutputStream

### 3.4.1.1. 既然有了字节流,为什么还要有字符流?

字符流由java虚拟机转换得到，问题时非常耗时和不知道编码格式会报错，干脆就提供直接操作字符的接口，方便对字符进行操作，如果是音频文件使用字节流，如果涉及到字符的话使用字符流。

### 3.4.1.2. BIO,NIO,AIO 有什么区别?

BIO：适用于连接数目小且固定的架构。阻塞io，常用的字符流和字节流都是阻塞IO，必须等文件传输完成，才能继续线程，Socket 和ServerSocket 属于这种

NIO:适用于连接数目多且链接比较短的架构。非阻塞io，在java.nio中有提供，分别使用Buffer、channel、selector 等抽象。SocketChannel 和 Socket 属于这种。	

AIO：适用于连接数目多且连接比较长（重操作）的架构。是异步IO，是基于事件和回调机制实现的。

1. # 基础

  ## 1.1. 正确使用 equals 方法

str.equals(""),容易抛出空指针异常。

经常使用"".equals(str)。

推荐使用Objects.equals(str,"");

##   1.2. 整型包装类值的比较

自动装箱，范围在-127~128之间，创建Integer对象回缓存起来，当下次出现该数值的时候，直接从缓存取出对应的Integer对象。

##   1.3. BigDecimal

###   1.3.1. BigDecimal 的用处

用于处理精确的小数点位数，浮点数比较，基本不用==来比较，也不能使用equals来判断。会产生精度丢失，推荐使用BigDecimal 来定义浮点数的值。

###   1.3.2. BigDecimal 的大小比较

```
BigDecimal a = new BigDecimal("1.0");
BigDecimal b = new BigDecimal("2.0");
System.out.println(a.compareTo(b));// -1 表示小于，0表示等于，1表示大于
```

###   1.3.3. BigDecimal 保留几位小数

通过 setScale 方法设置保留几位小数，以及规则。

###   1.3.4. BigDecimal 的使用注意事项

为了防止精度丢失，我们使用BigDecimal（String） 构造方法或者使用BigDecimal.valueOf(double)来创建对象，而不是使用BigDecimal(double) 的方式。

2. # 集合

  ## 2.1. Arrays.asList()使用指南

  将数组转换为List 集合，返回的是java.util.Arrays 内部的一个静态类，而不是真正java.util.ArrayList，本身还是数组，如果进行add,remove,clear操作会报不支持操作异常。如果对数组进行改变，arr[0] = 1; 那么list.get(0) 也会跟着改变。

传入的参数不能是基本类型的数组，必须包装成包装类再使用，否则生的列表大小为1

  ### 2.1.4. 如何正确的将数组转换为ArrayList?

  手动实现，for

  简便方法：new ArrayList(Arrays.asList('a','b'));

  Stream :

  ```
  Integer [] myArray = {1,2,3};
  List myList = Arrays.stream(myArray).collection(Collections.toList());
  ```

  Guava :

  ```
  List<String> il = ImmutableList.of("string", "elements");  // from varargs
  List<String> il = ImmutableList.copyOf(aStringArray);      // from array
  ```

  

  ## 2.2. Collection.toArray()方法使用的坑&如何反转数组

  

  ## 2.3. 不要在 foreach 循环里进行元素的 remove/add 操作

如果要进行remove 操作，可以使用迭代器的remove ，而不是集合类的remove，如果并发操作，需要对Iterator 对象加锁。如果通过集合类的remove/ add 方法进行，迭代器会抛出同时修改异常，这就是单线程下的fail-fast。

fail-fast ：是java集合的一种错误检测机制。多线程对fail-fast 集合进行修改时，可能会抛出同时修改异常，值得注意的时，单线程情况下， 如果操作不当，同时也可能抛出同时修改异常。java.util 包下面的所有集合都是fail-fast 的，而java.util.concurrent 包下面的所有类都是fail-safe 的。

foreach 遍历报异常的根本原因：ArrayList 中有成员变量modCount 还有一个内部类expectedModCount ,一个代表实际的修改次数，一个代表期望修改的次数。foreach 删除或者添加数据都是对modCount 进行修改，而没有对expectedModCount 进行修改，不想等，抛出异常。

## 2.4for循环中进行remove 操作，出现漏删的情况

for 循环是根据索引删除的，如果删除第一个值，那么list 会重新排序，所有的元素做位移操作，后面那个被删除的值会被挪到已经删除值得索引位置，就发生了漏删。

可以从后向前进行遍历，或者直接使用迭代器，使用Stream()，

### Servlet总结

Servlet 主要负责接受用户的请求，HttpServletRequest 使用Service（）方法，也就是doPost() 和doGet() 方法做出响应的处理。通过HttpServletResponse 对请求做出响应，Servlet 的生命周期有 init() service() destory() ,一个Servlet 类只有一个实例，Servlet 需要通过注解或者配置web.xml 文件，来实现对应的映射关系。一个Servlet 可以设置多个url 访问，Servlet 并不是线程安全的。

### 阐述Servlet和CGI的区别?

CGI的不足之处:

1，需要为每个请求启动一个操作CGI程序的系统进程。如果请求频繁，这将会带来很大的开销。

2，需要重复编写处理网络协议的代码以及编码。

Servlet的优点：

1，只需要启动一个操作系统进程以及加载一个JVM，大大降低了系统的开销

2，如果多个请求需要做同样处理的时候，这时候只需要加载一个类，这也大大降低了开销

3，所有动态加载的类可以实现对网络协议以及请求解码的共享。

4，Servlet能直接和Web服务器交互，而普通的CGI程序不能。

### Servlet接口中有哪些方法及Servlet生命周期探秘

init() 执行一次

service() 每次请求都会执行

destory() 执行一次

getServletInfo()

getServeltConfig()

### get和post请求的区别

两者几乎没有什么区别，底层都是tcp链接，get 是向服务器请求数据，post 是向服务提交数据。

关于安全性：http本身就是明文协议，每个HTTP请求和返回的每个byte都会在网络上明文传播，不管是url，header还是body。想要加密，使用https

关于编码：GET和POST实际上都能用url和body。因此所谓编码确切地说应该是http中url用什么编码，body用什么编码。

什么是请求体：从HTTP协议的角度，“请求头”就是Method + URL（含querystring）+ Headers；再后边的都是请求体。

关于url的长度：GET 的长度限制，其实就是url 的长度限制（2MB）

### 什么情况下调用doGet()和doPost()

methd 标签里是get 调用doGet() , 为post 的时候调用doPost()

### 转发（Forward）和重定向（Redirect）的区别

Forward：是服务器内部转发，url还是原来的url，可以共享request 中的数据，用于用户登录

Redirect：是客户端给服务器，服务器返回客户端，客户端再去请求，再次返回，url改变，不能共享request 中的数据，用于用户注销

### 自动刷新(Refresh)

servlet 中的HttpServletResponse 对象设置Header 属性可以实现自动刷新

Response.setHeader("Refresh","5;url=https://")

### Servlet与线程安全

servlet 本身是线程不安全的，多线程的并发读写会导致数据的不同步，讲要读的属性设置为final，要写的属性使用synchronized 或者ReentrantLock，线程安全的集合，不使用实例变量

ServletContext 和ServletSession 是线程安全的

### JSP和Servlet是什么关系

jsp：是加了java 代码的html，会先生成servlet，充当视图

servlet：应用逻辑实在java中，并完全从表示层分离，充当控制器

### JSP工作原理

先生成servlet ，然后编译成.class ，后面的request，都是通过运行.class 文件来响应客户端请求。

### JSP有哪些内置对象、作用分别是什么

out 输出服务器响应的输出流对象

request

response

session 用户的会话对象

exception 

application 服务器运行环境

page jsp页面本身

pagecontext jsp上下文，常用的操作，getServletContext getServletConfig

config

注意：ServletContext 和 Application一样，ServletContext 用于servlet，application用于jsp

### Request对象的主要方法有哪些

getRequestURL()

getQueryString()

getRemoteHost()

getHeader()

getHeaders()

getHeaderNames()

getParameter()

getParameterValues()

getParameterMap()

### request.getAttribute()和 request.getParameter()有何区别

getParameter() 是从请求获取参数，通过url 或者表单提交的参数，不需要设置，是String类型

getAttribute() 是从容器中获取参数，要想获取属性，必须先setAttribute 设置属性，设置和取都是Object 类型，重定向时可以使用setAttribute（），讲request 中有用的值传给下一处理request 的servlet

### servlet 中的常用作用域：

page：指代当前页页面

request:从请求到请求结束

session:会话的有效范围，打开浏览器到关闭的过程

application:有效范围是整个应用,与servletContext 的作用范围是一样

pagecontext:jsp页面结束，都可以使用这个范围

### include指令include的行为的区别

指令：用来包含其他文件，包含的文件可以是jsp文件，html和文本文件，包含的文件就是jsp的一部分，格式如下：<%@ include file="" %>，运行前，将所有文件经编译合成一个.class 文件。

行为：用来包含静态和动态文件，独立的字节码文件，当执行到该动作才加载被包含的字节码文件

### JSP七大动作，三大指令

三大指令：page、include、taglib

七大动作：

jsp:include

jsp:useBean

jsp:setProperty

jsp:getProperty

jsp:forward

jsp:plugin

### 讲解JSP中的四种作用域

page

request

session

application

### 如何实现JSP或Servlet的单线程模式

jsp:<%page isThreadSafe="false"%>

servlet:SingleThreadModel

### Cookie和Session的的区别

cookie:永久保持，不需要服务器资源，大小收到限制，有安全风险

session:服务器记录用户的状态，

### final 关键字

修饰类，表示不可继承（所有成员方法都会被隐式的指定为final方法），修饰方法，表示不可重写，修饰属性，表示常量（基本数据类型一旦初始化，不能修改，引用类型，一旦初始化， 不能指向其他对象）

### static 关键字

修饰块，类的初始化工作（只执行一次），修饰成员变量，表示变量属于类（可以通过对象和类进行访问），修饰成员方法，表示方法属于类（只能使用静态成员方法，可以通过类和对象进行调用），静态内部类，他的创建不需要外围类的创建，她不能使用外围类的非static 方法。

### this 关键字

指代当前对象，通过this() 来调用构造函数

### super 关键字

指代父类对象，通过使用super（）来调用父类的构造函数

注意：在构造器中调用父类的super()方法时，放首行，this（）同样

### static{}静态代码块与{}非静态代码块(构造代码块)

static{}:对类进行初始化，只执行一次，一般是对static 进行赋值

{}:对对象进行初始化，没次创建对象执行一次

### 获取Class 对象的方式

TargetObject.class

对象.getClass()

class.forName("")

### 反射的一些常用api

Class xxx = 通过三种方式获取class 对象

Method[] methods = xxx.getDeclaredMethods();

Method method = xxx.getDeclaredMethod("",String.class);

method.invoke(xxx,"实参");

Field field = xxx.getDeclaredField("value");

field.setAccessible(true);

field.set(xxx,"实参");

### 反射的优缺点

运行时加载，灵活，动态类加载

性能差，安全差

## 反编译

### 自动拆装箱

装箱，使用valueOf()，拆箱，使用xxxValue()

### foreach

数组使用for，集合使用迭代器（使用foreach，进行remove，会出现问题）

### Array.asList

传入的参数不能是基本类型的数组，必须包装成包装类再使用，否则生的列表大小为1（传入基本类型数组，会被转换成二维数组）

 将数组转换为List 集合，返回的是java.util.Arrays 内部的一个静态类，而不是真正java.util.ArrayList，本身还是数组，如果进行add,remove,clear操作会报不支持操作异常。如果对数组进行改变，arr[0] = 1; 那么list.get(0) 也会跟着改变。

### 注解

public @interface Foo 会被转换成 public interface Foo extends Annotation

属性String[] value(); 被转换成抽象方法 public abstract String[] value();

## Java性能问题

### jstack

堆栈分析

### jstat

运行的实施状况

### jmap

查看堆内存的初始化信息以及堆内存



## 1.1. 集合概述

![image-20200812213612336](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200812213612336.png)

带hash 的插入顺序无序，link 的插入有序

### 1.1.2. 说说 List,Set,Map 三者的区别？

List ：元素有序，可重复

Set：元素无序，不可重复

Map:由键值对构成，key无序，不可重复，value无序，可重复

### 1.1.3. 集合框架底层数据结构总结

List:ArrayList 底层是数组，Vector 底层数组，LinkedList,双向链表

Set:HashSet 底层是HashMap,LinkedHashSet 底层是LinkedHashMap 来实现的，TreeSet,红黑树

Map:HashMap 数组+链表（链表长度大于8，转为红黑树），LinkedListMap 数组和双向链表（红黑树），Hashtable 数组和双向链表，TreeMap 红黑树

### 1.1.5. 为什么要使用集合？

数组：长度固定，类型相同

集合：长度不固定，不同类型

### 1.1.6.2. 迭代器 Iterator 有啥用？

主要用来遍历集合，特点是更加安全，通过foreach 遍历集合，底层就是用的iterator，可以确保遍历集合时，做出修改，会报同时修改异常，直接通过 集合对象的iterator() 方法进行转换。（map 使用 map.entrySet().iterator()）

### 1.1.7. 有哪些集合是线程不安全的？怎么解决呢？

通过线程安全的集合使用，在java.util.concurrent 包下，

ConcurrentHashMap 代替HashMap

CopyOnWriteArrayList 线程安全的ArrayList

ConcurrentLinkedQueue 线程安全的队列

BlockingQueue 阻塞队列

ConcurrentSkipListMap 跳表

### 1.2.1. Arraylist 和 Vector 和LinkedList的区别?

ArrayList:线程不安全，底层是数组，用于频繁的查找，支持随机访问

Vector:线程安全，底层是数组

ArrayList：线程不安全，使用的双向链表，用于频繁的删除和插入，不支持随机访问

### 1.2.2.2. RandomAccess 接口

是一个标识接口，标识这个接口的类具有随机访问的功能。在binarySearch 方法中，如果传入的List 是RandomAccess 的子类，调用indexedBinarySearch()，如果不是，那么调用 iteratorBinarySearch()，只有底层是数组才能实现 RandomAccess 

### 1.2.3. ArrayList 的扩容机制

使用无参构造函数，是一个空数组，第一次add,默认长度是10，也可以通过构造函数自己设定数组的长度，当add时，长度大于现在的数组长度，会进行扩容 int newCapacity = oldCapacity + (oldCapacity >> 1)，相当于每次会变成原来的1.5倍。

### 常用的长度方法和属性

length 针对于数组，是属性

length() 针对于字符串，是方法

size() 针对于集合，是方法

### System.arrayCopy 和 Arrays.copyOf()

System.arraycopy（源数组，起始位置，目标位置，目标数组，起始位置，复制的数量），源和目标都要提供

Arrays.copyOf （源数组，长度，类型），只提供源，返回目标，底层用的是 System.arraycopy

### 1.3.1. comparable 和 Comparator 的区别

comparable：接口，来自java.lang，有一个方法compareTo(Object obj)

comparator：接口，来自java.utils，有一个方法compare(Object obj1,Object obj2)

### 1.3.1.1. Comparator 定制排序

Arrays.sort(数组，comparator) // 通过实现comparator 来实现排序

Collections.sort(数组，comparator)// 通过实现comparator 来实现排序

普通的类通过实现 comparable接口，重写compareTo 方法来排序

### 1.3.3. 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同

HashSet 底层是HashMap，不重复，无顺序

LinkedHashSet 底层是LinkedHashMap，不重复，按顺数加入

TreeSet,红黑树，不重复，从小到大排序

### 1.4.1. HashMap 和 Hashtable 的区别

HashMap:线程不安全，性能好，默认容量是16，每次扩容变成两倍，构造函数带参数，按照2的幂次方分配空间

Hashtable：线程安全，表锁，性能差，默认容量是11，每次扩容2N+1，构造函数带参数，按照给定参数分配空间

### 1.4.2. HashMap 、TreeMap和 HashSet 区别

HashMap ：实现map接口，存储键值对，使用put，使用key 计算hashcode

HashSet ：实现set接口，存储对象，使用add，使用对象计算hashcode

TreeMap：相比于`HashMap`来说 `TreeMap` 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。

### 1.4.4. HashSet 如何检查重复

如果存入的对象没有实现 hashcode（）和equals（） 方法，那么通过内存地址的比较去重，如果实现了hashcode（）和equals（）方法，那么根据属性或者相关的比较，进行去重。

### 1.4.5. HashMap 的底层实现

数组跟链表，默认长度是16，数组扩容采用的是2的n次幂，如果链表的长度小于8，使用链表，如果链表的长度大于8，先判定数组的长度小于64不，小于那么先扩容数组，如果大于，那么将链表转换为红黑树。

### 1.4.6. HashMap 的长度为什么是 2 的幂次方

减少碰撞，Hash 值的范围值-2147483648 到 2147483647，先取模，然后才能使用，把数据均匀分配使用，下标计算方法hash&（n-1），hash%length == hash&（n-1）的前提条件是n 为 2的n次幂。

### 1.4.7. HashMap 多线程操作导致死循环问题

并发的情况下，Rehash会造成元素之间形成循环链表，多线程不推荐使用

### 1.4.8. HashMap 有哪几种常见的遍历方式?

map.entrySet().Iterator()

map.keySet().Iterator()

map.keySet()

map.entrySet()

map.foreach()

map,entrySet().stream.forEach()

### 1.4.9. ConcurrentHashMap 和 Hashtable 的区别

ConcurrentHashMap : node数组跟链表红黑树实现，并发使用synchronized 和cas 实现（synchronized 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发）

Hashtable :底层使用数组跟链，用synchronize保证安全，

## 1.5. Collections 工具类

### 1.5.1. 常用操作操作

排序

```
void reverse(List list)//反转
void shuffle(List list)//随机排序
void sort(List list)//按自然排序的升序排序
void sort(List list, Comparator c)//定制排序，由Comparator控制排序逻辑
void swap(List list, int i , int j)//交换两个索引位置的元素
void rotate(List list, int distance)//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面
```

查找替换

```
int binarySearch(List list, Object key)//对List进行二分查找，返回索引，注意List必须是有序的
int max(Collection coll)//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)
int max(Collection coll, Comparator c)//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)
void fill(List list, Object obj)//用指定的元素代替指定list中的所有元素。
int frequency(Collection c, Object o)//统计元素出现次数
int indexOfSubList(List list, List target)//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target).
boolean replaceAll(List list, Object oldVal, Object newVal), 用新元素替换旧元素
```

同步控制（效率低下， 不建议使用）

```
synchronizedCollection(Collection<T>  c) //返回指定 collection 支持的同步（线程安全的）collection。
synchronizedList(List<T> list)//返回指定列表支持的同步（线程安全的）List。
synchronizedMap(Map<K,V> m) //返回由指定映射支持的同步（线程安全的）Map。
synchronizedSet(Set<T> s) //返回指定 set 支持的同步（线程安全的）set。
```



### 1.6.1. 什么是快速失败(fail-fast)？

是java集合的错误检测机制，当使用迭代器遍历的时候，我们在多线程下操作非安全的结合类会触发快速失败，常抛出的异常同时修改异常，单线程下，通过foreach遍历数组时，修改集合的内容也会触发快速失败机制。

本质原因是modeCount 和exceptedModCount 的值不一致导致的。

### 1.6.2. 什么是安全失败(fail-safe)呢？

采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历，不会报同时修改异常。

### 1.6.3. Arrays.asList 避坑

Arrays.asList() 将数组转换成集合，底层还是数组，数组变，集合跟着变

Arrays.asList()中的参数必须是对象数组，不能是基本类型，否则 集合的长度为1（当传入一个原生数据类型数组时，`Arrays.asList()` 的真正得到的参数就不是数组中的元素，而是数组对象本身，一个地址，此时 List 的唯一元素就是这个数组。）

Arrays.asList() 返回的集合并不是ArrayList，而是一个内部类，使用add/remove等方法，报不支持修改

1. # 什么是线程和进程?

  进程：程序的一次执行过程，运行程序的基本单位，程序运行时，jvm启动进程，进程相互独立，开销大，有利于资源的管理和保护

  线程：进程的更小执行单位，共享堆和方法区的资源，自己的本地方法栈、程序计数器、虚拟栈，开销小，不利于资源的管理和保护

##   2.2. 程序计数器为什么是私有的?

作用：字节码通过改变程序计数器来以此读取指令，实现代码的流程控制，多线程下，程序计数器用于记录当前线程的执行位置（上下文切换）。

注意：native 方法 程序计数器是undefined地址，java代码时才是下一条指令的地址。

##   2.3. 虚拟机栈和本地方法栈为什么是私有的?

java 在执行方法的同时会创建一个栈帧用来存储局部变量表、常量池引用等信息，因为保证局部变量不被其他线程访问，所以是私有的

##   2.4. 一句话简单了解堆和方法区

堆：数组和对象

方法区：类信息，常量、静态变量、编译器编译后的代码数据

## 3.1说说并发与并行的区别?

并发：时间段内，多任务都在执行

并行：单位时间内，多任务同时执行

## 4.1为什么要使用多线程呢?

计算机底层：线程是轻量级的进程，消耗的资源少，线程间切换和调度成本小，多核的cpu时代代表，多个线程可以同时运行，

互联网趋势：千万级的并发量，利用线程机制可以提高并发量

带来的问题：死锁、内存泄漏、线程不安全

## 5.1说说线程的生命周期和状态?

new:线程被构建，还没有start（）

runnable：running（运行） 和ready（就绪），调用start（）方法开始后，先进入就绪状态，获取时间片进入到running 状态

blocked：阻塞状态，在没有获取到锁的情况下（阻塞）

waiting：进入线程等待，当前线程需要其他线程的通知，相当于方法wait（）

time_waiting:在指定的时间自行返回，相当于方法wait（millis）或者sleep（millis）

terminated:表示线程执行完毕，run（）方法结束

## 6.1什么是上下文切换?

每个cpu核心只能被一个线程使用，时间片结束，线程切换，线程切换的过程就叫上下文切换，也就是任务从保存到再加载的过程就是一次上下文切换

## 7.1. 认识线程死锁

多个线程同时被阻塞，他们其中一个等待某个资源被释放，由于线程被无限期的阻塞，程序不能 正常终止，A持有资源2，B持有资源1，都想申请对方的资源，就会进入死锁

##  7.2. 如何避免线程死锁?

破坏互斥条件：本身就是让线程互斥，没办法破坏

破坏请求和保持条件： 一次申请所有的资源

破坏不剥夺：申请不到，就释放

破坏循环等待：按照顺序申请资源（上述的，AB持有资源，改为先申请资源1，然后再申请资源2）

## 8.1说说 sleep() 方法和 wait() 方法区别和共同点?

sleep（）:持有锁，用于暂停执行，会自动苏醒

wait（）：释放锁，用于线程间通信，需要别的线程进行通知

wait（）和wait（time)：不带参数需要别的线程通知叫醒，带参数则是到时间后苏醒。

## 8.2为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？

start（）：启动线程，线程进入就绪状态

run（）：类下的一个普通方法，在main 线程下的执行



## 1.1.synchronized 关键字

解决并发问题的一种简单方式，只需要给方法、代码块加上关键字就行，从关键字的地方进行加锁，执行完成锁释放，jvm会自动实现.synchronized 修饰方法时锁定的是调用该方法的对象。它并不能使调用该方法的多个对象在执行顺序上互斥。静态方法是只要是该类对象都是同一把锁。尽量不要给包装类型和String 类型加锁,字符串常量有缓存功能。

## 1.2. 双重检验锁实现单例模式

```
public static Singleton{
	private volatile staic Singleton uniqueInstance;
	private Singleton(){}
	public static Singleton getUniqueInstance(){
		if(uniqueInstance ==null){
			sychronize(Single.class){
				if(uniqueInstance ==null){
					uniqueInstance = new Singleton();
				}
			}
		}
		return uniqueInstance;
	}
}
```

## 1.3. 讲一下 synchronized 关键字的底层原理

synchronized 修饰代码块:翻译成字节码对应的式monitorenter 和 monitorexit 指令,monitorenter 代表指令开始的地方,monitorexit 代表指令结束的地方.synchronized 修饰方法:翻译成字节码对应的是一个标识ACC_SYNCHRONIZED.

## 1.4. 说说 JDK1.6 之后的synchronized 关键字底层做了哪些优化(虚拟机层面)

偏向锁:为了没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗,偏向锁的“偏”就是偏心的偏，它的意思是会偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步

轻量级锁:它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，因为使用轻量级锁时，不需要申请互斥量。另外，轻量级锁的加锁和解锁都用到了CAS操作.如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥操作的开销。但如果存在锁竞争，除了互斥量开销外，还会额外发生CAS操作.

自旋锁:一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的。让后面来的请求获取锁的线程等待一会而不被挂起.(调用者一直循环,查看自旋锁的保持者是否已经释放了锁),默认自旋十次,就应该挂起线程

消除锁:如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。锁消除可以节省毫无意义的请求锁的时间。

锁粗化:推荐将同步块的作用范围限制得尽量小

## 1.5. 谈谈 synchronized和ReentrantLock 的区别

synchronized:可重入锁(自己的内部还可以获取锁,不可重入再次获取的化会造成死锁,每次获取锁的计数器增加1,0代表锁释放),依赖于jvm,有异常会释放锁

ReentrantLock:可重入锁(自己的内部还可以获取锁,不可重入再次获取的化会造成死锁,每次获取锁的计数器增加1,0代表锁释放),依赖于api,高级功能(等待可中断,实现公平锁,可选择性通知),有异常需要再finally 进行释放

等待可中断:使用lock.lockInterruptibly() 实现,等待的线程可以放弃等待,改为处理其他事情

实现公平锁:公平就是先等待的线程先获得锁,默认是不公平的,通过ReentrantLock(boolean) 构造方法来设置公平不公平

可选择性通知:线程对象可以注册再Condition 中,从而可以选择性的进行线程通知,使用notify 和 notifyall 来通知,用ReentrantLock 类结合Condition 实例可以实现"选择性通知"

满足需求的情况先,优先使用synchronized

## 2.1. volatile关键字

修饰变量,这个变量是稳定不变的,每次使用它都需要去共享内存中读取,作用是保证变量的可见性,防止指令重排

### 2.2 并发的三个重要特性

原子性:一次操作,要么都执行,要么都不执行,synchronized保证

可见性:当一个线程对共享变量进行修改,另外的线程立刻可以啊看到修改后的值,volatile保证

有序性:执行时有先后,java编译器会进行优化,执行顺序未必就是编写顺序,volatile 可以禁止指令重排

### 2.3说说 synchronized 关键字和 volatile 关键字的区别

synchronized:修饰方法,代码块 ,性能差点,会阻塞,原子性和可见性都能保证,多线程访问资源的同步性

volatile:修饰变量,性能好,不会阻塞,可见性和有序性可以保证,解决变量在多线程之间的可见性

## 3.1. ThreadLocal简介

![image-20200816211618398](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200816211618398.png)

是一个类,主要的作用就是为每个线程都有一个本地专属的值,如果创建了一个ThreadLocal 变量,那么每个访问这个变量的线程都会有这个变量的本地副本,从而避免线程安全问题(两个人拿一个袋子收集宝物,肯定会产生争执,每人分配一个袋子就没问题)

## 3.3. ThreadLocal原理

set方法

```
public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
    	map.set(this, value);
    else
    	createMap(t, value);
}
ThreadLocalMap getMap(Thread t) {
	return t.threadLocals;
}
```

![image-20200816212922313](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200816212922313.png)

最终变量是存在线程对象的ThreadLocalMap 上的,不是ThreadLocal上的,每个`Thread`对象中都具备一个`ThreadLocalMap`，而`ThreadLocalMap`可以存储以`ThreadLocal`为key ，Object 对象为 value的键值对。

## 3.4. ThreadLocal 内存泄露问题

ThreadLocalMap中使用的 key 为 `ThreadLocal` 的弱引用,而 value 是强引用。所以，如果 `ThreadLocal` 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，`ThreadLocalMap` 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap实现中已经考虑了这种情况，在调用 `set()`、`get()`、`remove()` 方法的时候，会清理掉 key 为 null 的记录。使用完 `ThreadLocal`方法后 最好手动调用`remove()`方法

## 4.1. 为什么要用线程池？

就像cpu 的核心数一样,提供了一种限制和资源管理,线程池的好处,降低资源消耗(创建和销毁线程的损耗),提高响应速度(任务来时,不需要等待线程的创建就能立刻执行),提高线程的可管理性(统一分配 监控)

## 4.2. Runnable接口和Callable接口的区别

Runnable:接口 ,实现run()方法,任务执行完没有返回值或者抛出异常

Callable:接口,实现call()方法,有返回值和抛出异常

工具类Executors 可以实现Runnable 和 Callable 对象之间的互相转换

## 4.3. Executors执行execute()方法和submit()方法的区别？

execute():不需要返回值,无法判定任务执行成功与否

submit():返回Futrue,可以通过future 判断任务执行成功与否

## 4.4. 如何创建线程池

通过ThreadPoolExecutor 构造方法实现

通过工具类Executors 来实现(底层还是通过ThreadPoolExecutor 实现)

- **FixedThreadPool** ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。
- **SingleThreadExecutor：** 方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。
- **CachedThreadPool：** 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。

### 4.4.1 ThreadPoolExecutor 参数

- **`corePoolSize` :** 核心线程数线程数定义了最小可以同时运行的线程数量。
- **`maximumPoolSize` :** 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。
- **`workQueue`:** 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。
- **`keepAliveTime`**:当线程池中的线程数量大于 `corePoolSize` 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 `keepAliveTime`才会被回收销毁；
- **`unit`** : `keepAliveTime` 参数的时间单位。
- **`threadFactory`** :executor 创建新线程的时候会用到。
- **`handler`** :饱和策略。关于饱和策略下面单独介绍一下。

### 4.4.2 饱和策略

- **`ThreadPoolExecutor.AbortPolicy`**：抛出 `RejectedExecutionException`来拒绝新任务的处理。
- **`ThreadPoolExecutor.CallerRunsPolicy`**：调用自己的线程运行任务，如果应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。
- **`ThreadPoolExecutor.DiscardPolicy`：** 不处理新任务，直接丢弃掉。
- **`ThreadPoolExecutor.DiscardOldestPolicy`：** 此策略将丢弃最早的未处理的任务请求。

### 4.4.3 线程池原理分析

线程池每次会同时执行 5 个任务，这 5 个任务执行完之后，剩余的 5 个任务才会被执行。

![image-20200816221038682](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200816221038682.png)

5. Atomic 原子类
5.1. 介绍一下Atomic 原子类
5.2. JUC 包中的原子类是哪4类?
5.3. 讲讲 AtomicInteger 的使用
5.4. 能不能给我简单介绍一下 AtomicInteger 类的原理
6. AQS
6.1. AQS 介绍
6.2. AQS 原理分析
6.2.1. AQS 原理概览
6.2.2. AQS 对资源的共享方式
6.2.3. AQS底层使用了模板方法模式
6.3. AQS 组件总结
7 Reference

### jvm 调优

主要目的是保持虚拟机的稳定，而不是带来性能的大幅度提升，出现的相关问题，比如服务器运行多少小时，会产生oom，或者直接死机。又比如full gc 时间长，带来的服务暂停明显。解决办法，就是尽量让大对象在年轻代被回收，调整大对象在年前带的回收频次。

jvm 核心为调整年轻代、老年代的内存空间以及使用GC发生器的类型。在jar包所在的目录建立一个start.sh 文件，文件内容java -server -Xms4G //jvm启动时最大内存

-Xmx4G //jvm 整个堆的最大值

-Xmn2G //年轻代大小，剩下的是老年代大小

-XX:SurvivorRatio=1 // 设置Eden：s0：s1 之间的比例信息

-XX:+UseConcMarkSweepGC //回收器类型 这里是CMS，1.7 使用G1

-Dcom.sun.management.jmxremote 

-Dcom.sun.management.jmxremote.port=1100 

-Dcom.sun.management.jmxremote.authenticate=false 

-Dcom.sun.management.jmxremote.ssl=false -jar c1000k.jar&

### CMS 和G1

新生代：回收频率较高，选择新能较高的收集器

老年代：收集次数较少，应避免选择基于复制算法的回收器

垃圾收集器执行的时刻，应用程序需要暂停运行

可以串行收集，也可以并行收集

CMS:是最短回收停顿时间为目标的收集器，GC工作线程可以跟用户线程可以并发执行，以此来降低收集停顿时间的目的。作用于老年代的收集，基于标记-清除算法的，步骤分为4个步骤：初始标记‘、并发标记、重新标记、并发清除，其中的初始标记和重新标记仍然需要应用程序的暂停运行。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始阶段稍长一些，但远比并发标记的时间短。

CMS优点：只有初始标记、重新标记两次暂停，达到了近似并发的目的、并发收集

CMS缺点：cpu资源敏感、无法处理浮动垃圾、可能产生内存碎片

G1:从整体上是标记-整理算法，从局部上是基于复制的算法。意味着不会出现内存碎片，这种特征有利于长时间程序的运行，分配对象不会因为找不到空间而提前触发下一次GC，G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。过程如下：初始标记、并发标记、最终标记、筛选回收。初始标记，能直接关联到GC Root 的对象，停顿线程；并发标记，可达性分析，找出存活的对象；最终标记，停顿线程；

### 中间件

将具体业务和底层逻辑解耦的组件，java 常见的中间件有，tomcat、Weblogic、JBOSS、Coldfusion、Websphere、GlassFish

### 用户态和内核态

分为两个状态的原因是因为不让os崩溃，直接操作内核态可能会导致系统崩溃，从而建立用户态保护系统。

用户态：受限访问内存，不允许访问外围设备，占用cpu的能力、资源

内核态：可以访问内存中的所有数据，包括外围设备，硬盘，网卡，cpu

### cpu 线程进程

CPU：4核心 4线程。4核指的是物理核心（物理概念）。4线程（线程数是一个逻辑概念）

进程：是操作系统（OS）进行资源（CPU、内存、磁盘、IO、带宽等）分配的最小单位

线程：是**CPU**调度和分配的基本单位




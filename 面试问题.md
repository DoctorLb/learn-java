```bash
# 一级标题
## 二级标题
### 三级标题
#### 四级标题
##### 五级标题
###### 六级标题
```

```swift
//形式一
+ a
+ b
+ c
//形式二
- d
- e
- f
//形式三
* g
* h
* i
```

```cpp
//正常形式
1. abc
2. bcd
3. cde
//错序效果
2. fgh
3. ghi
5. hij
```

```cpp
//无序列表嵌套
+ 123
    + abc
    + bcd
    + cde
+ 465
+ 789
//有序列表嵌套
1. abcd
    1. abcde
    2. abcde
    3. abcde
2. bcde
3. cdef
```

```ruby
> 一级引用
>> 二级引用
>>> 三级引用
>>>> 四级引用
>>>>> 五级引用
>>>>>> 六级引用
```

~~~go
//大量代码    
```
        daliangdaima,xuyaoduohangshiyong
        daliangdaima,xuyaoduohangshiyong
        daliangdaima,xuyaoduohangshiyong
        daliangdaima,xuyaoduohangshiyong
        daliangdaima,xuyaoduohangshiyong
    ```
~~~

```undefined
//分割线
---
- - -
------
***
* * *
******
___
_ _ _
______
```

```undefined
//强调字体
*md*    
**md**
_md_   
 __md__
```

```undefined
\\
\*
\+
\-
\`
\_
```

```undefined
~~删除~~
```

---



### Java中的filter 的

#### 三个参数

ServletRequest

ServletResponse 

FilterChain

#### 生命周期

init

doFilter

destory

#### web.xml 配置

<filter>

<filter-name>

<filter-class>

<init-param>

<param-name>

<param-value>

<filter-mapping>

<filter-name>

<url-pattern>

#### 应用

编码格式的转换 和 登录过滤

---

### Maven

#### 作用

标准化的项目结构

标准化的构建流程

管理机制

#### pom.xml说明

groupId 公司或者组织的id

artifactId 项目名称

version 

dependency 依赖

parent 父项目

dependencies 项目依赖

dependency 具体的依赖

#### 生命周期

##### 标准生命周期

clean 项目的清理

default/build 项目的部署

site 项目站点文档创建处理

###### default/build 生命周期

validata 验证项目

compile

test

package

verify 检查

intall 安装，将打包的项目安装到本地

deploy 部署，拷贝工程到远程仓库有

###### clean 的生命周期

pre-clean

clean

post-clean

###### site 生命周期

pre-site

site

post-site

site-deploy

---

### Vue

使用基于 HTML 的模板语法，声明式的将 DOM 绑定到 Vue 实例数据

#### 安装

npm install 安装依赖

npm run dev 运行程序

#### 语句

v-if 条件判断

v-else else 块

v-else-if else if 块

v-for 条件循环,如果是键值对，可使用多个参数，例如v-for="(value,key) in object"

#### 属性

计算属性 computed 只有在依赖改变时，才会重新取值

监听属性 watch 用于响应数据的变化

data 的数据，变量不用引号，在 main 中是属性，在组件中是函数，好处是每个实例维护一份被返回对象的独立拷贝

#### 指令

v-html 绑定 data 中的变量，用于输出 html 代码

v-bind/: 双向绑定 data 中的变量，也可以绑定 style 和 class，例如v-bind:class=""

v-model 单向绑定 data 中的变量，表单实现双向绑定	

v-show 根据条件来展示元素

v-on/@ 对于事件的处理，例如v-on:keyup.enter=""

#### 组件

vue 组件 封装可用的代码，全局和局部组件，父组件通过 props 把数据传给子组件，子组件通过 $on 监听事件和 $emit 触发事件，传回给父组件

#### 路由

下载 npm run vue-router

##### router-link

to 当被电击是会立即把 to 的值传到 router.push(),这个值可以是一个字符串或者是描述目标位置的对象

replace 调用的是 rourer.replace() 导航后不会留下 history 记录

append 追加路径属性

tag <router-link>想要渲染成某种标签

acitve-class 链接激活时使用的 CSS 类名

event  用来触发导航事件

---



#### 后端生成文档

1. 使用AdobeAcrobatpro，设计pdf文档模板
2. 获取模板文档路径
3. HttpServletResponse 设置头，content-type 设置为 Application/pdf
4. 读取模板，对象PdfReader
5. 转换成字节流
6. 创建可操作的 pdf 模板对象，PdfStamper
7. 封装数据，AcoFields
8. 填充数据
9. 设置是否可修改
10. 关闭资源

---

### JPA

创建表

自动实现保存和删除

#### JPA Hibernate 关系

JPA 是一种规范，不是框架

Hibernate 是JPA的一种实现，是框架

#### 注解

@Entity

@Table

@Id

@GenterateValue 指定如何标识属性可以被初始化

@Transient

@Column

@TableGenerator

#### 定义JPA接口

public interface XXRepository extends JpaRepository<XX,String>{}

#### JPA关键字

And

Or

Is/Equals

Between

LessThan

LessThanEqual

GreaterThan

GreaterThanEqual

After

Before

IsNull

Like

NotLike

OrderBy

### MyBatis

#### 什么是mybatis

MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。

#### 功能框架

1. API接口层：提供给外部使用的接口API，开发人员通过这些本地API来操纵数据库。接口层一接收到调用请求就会调用数据处理层来完成具体的数据处理。
2. 数据处理层：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的目的是根据调用的请求完成一次数据库操作。
3. 基础支撑层：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑。

#### 优点

- 简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。
- 灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。 sql写在xml里，便于统一管理和优化。通过sql基本上可以实现我们不使用数据访问框架可以实现的所有功能，或许更多。
- 解除sql与程序代码的耦合：通过提供DAL层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。
- 提供映射标签，支持对象与数据库的orm字段关系映射
- 提供对象关系映射标签，支持对象关系组建维护
- 提供xml标签，支持编写动态sql。

#### 缺点

- 编写SQL语句时工作量很大，尤其是字段多、关联表多时，更是如此。
- SQL语句依赖于数据库，导致数据库移植性差，不能更换数据库。
- 框架还是比较简陋，功能尚有缺失，虽然简化了数据绑定代码，但是整个底层数据库查询实际还是要自己写的，工作量也比较大，而且不太容易适应快速数据库修改。
- 二级缓存机制不佳

#### xml配置

MyBatis 的配置文件包含了影响 MyBatis 行为甚深的设置（settings）和属性（properties）信息。

##### properties

这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。

<properties resource="org/mybatis/example/config.properties">  

<property name="username" value="dev_user"/>  

<property name="password" value="F2Fa3!33TYyg"/> 

</properties>

如果属性在不只一个地方进行了配置，那么 MyBatis 将按照下面的顺序来加载：

因此，通过方法参数传递的属性具有最高优先级，resource/url 属性中指定的配置文件次之，最低优先级的是 properties 属性中指定的属性。

##### settings

这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。下表描述了设置中各项的意图、默认值等。

<settings>   

<setting name="cacheEnabled" value="true"/>   

<setting name="lazyLoadingEnabled" value="true"/>   

<setting name="multipleResultSetsEnabled" value="true"/>   

<setting name="useColumnLabel" value="true"/>   

<setting name="useGeneratedKeys" value="false"/>   

<setting name="autoMappingBehavior" value="PARTIAL"/>   

<setting name="defaultExecutorType" value="SIMPLE"/>   

<setting name="defaultStatementTimeout" value="25"/>   

<setting name="safeRowBoundsEnabled" value="false"/>   

<setting name="mapUnderscoreToCamelCase" value="false"/>   

<setting name="localCacheScope" value="SESSION"/>   

<setting name="jdbcTypeForNull" value="OTHER"/>   

<setting name="lazyLoadTriggerMethods" value="equals,clone,hashCode,toString"/> 

</settings>

##### typeAliases

类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。

<typeAliases>   

<typeAlias alias="Author" type="domain.blog.Author"/>   

<typeAlias alias="Blog" type="domain.blog.Blog"/>   

<typeAlias alias="Comment" type="domain.blog.Comment"/>   

<typeAlias alias="Post" type="domain.blog.Post"/>   

<typeAlias alias="Section" type="domain.blog.Section"/>   

<typeAlias alias="Tag" type="domain.blog.Tag"/> 

</typeAliases>//为全限定名设置一个短的名字

<typeAliases>  <package name="domain.blog"/> </typeAliases> // 配置包名

@Alias("author") //注解方式

##### typeHandlers

无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。 具体做法为：实现 `org.apache.ibatis.type.TypeHandler` 接口， 或继承一个很便利的类 `org.apache.ibatis.type.BaseTypeHandler`， 然后可以选择性地将它映射到一个 JDBC 类型。

<typeHandlers>  

<typeHandler handler="org.mybatis.example.ExampleTypeHandler"/> 

</typeHandlers>

##### 处理枚举类型

若想映射枚举类型 `Enum`，则需要从 `EnumTypeHandler` 或者 `EnumOrdinalTypeHandler` 中选一个来使用。

比如说我们想存储取近似值时用到的舍入模式。默认情况下，MyBatis 会利用 `EnumTypeHandler` 来把 `Enum` 值转换成对应的名字。

注意 `EnumTypeHandler` 在某种意义上来说是比较特别的，其他的处理器只针对某个特定的类，而它不同，它会处理任意继承了 `Enum` 的类。

使用 Mapper 接口，并不对接口进行实现，底层使用动态代理来实现，接口的全限定名就是 namespace 的值，当调用接口方法时，全限定名+方法名拼接成的 key 对应的一个唯一的 MappedStatement 

##### 配置环境

MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中， 现实情况下有多种理由需要这么做。例如，开发、测试和生产环境需要有不同的配置；或者共享相同 Schema 的多个生产数据库， 想使用相同的 SQL 映射。许多类似的用例。

不过要记住：尽管可以配置多个环境，每个 SqlSessionFactory 实例只能选择其一。

所以，如果你想连接两个数据库，就需要创建两个 SqlSessionFactory 实例，每个数据库对应一个。而如果是三个数据库，就需要三个实例，依此类推。

<environments default="development">   

<environment id="development">     

<transactionManager type="JDBC">       

<property name="..." value="..."/>     

</transactionManager>     

<dataSource type="POOLED">       

<property name="driver" value="${driver}"/>       

<property name="url" value="${url}"/>       

<property name="username" value="${username}"/>       

<property name="password" value="${password}"/>     

</dataSource>   

</environment> 

</environments>

##### 事务

<transactionManager type="MANAGED">  <property name="closeConnection" value="false"/> </transactionManager>

##### 数据源

###### UNPOLLED

这个数据源的实现只是每次被请求时打开和关闭连接。虽然一点慢，它对在及时可用连接方面没有性能要求的简单应用程序是一个很好的选择。 不同的数据库在这方面表现也是不一样的，所以对某些数据库来说使用连接池并不重要，这个配置也是理想的。

- `driver` – 这是 JDBC 驱动的 Java 类的完全限定名（并不是JDBC驱动中可能包含的数据源类）。
- `url` – 这是数据库的 JDBC URL 地址。
- `username` – 登录数据库的用户名。
- `password` – 登录数据库的密码。
- `defaultTransactionIsolationLevel` – 默认的连接事务隔离级别。

###### POLLED

这种数据源的实现利用"池"的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。 这是一种使得并发 Web 应用快速响应请求的流行处理方式。

- `poolMaximumActiveConnections` – 在任意时间可以存在的活动（也就是正在使用）连接数量，默认值：10
- `poolMaximumIdleConnections` – 任意时间可能存在的空闲连接数。
- `poolMaximumCheckoutTime` – 在被强制返回之前，池中连接被检出（checked out）时间，默认值：20000 毫秒（即 20 秒）
- `poolTimeToWait` – 这是一个底层设置，如果获取连接花费的相当长的时间，它会给连接池打印状态日志并重新尝试获取一个连接（避免在误配置的情况下一直安静的失败），默认值：20000 毫秒（即 20 秒）。
- `poolPingQuery` – 发送到数据库的侦测查询，用来检验连接是否处在正常工作秩序中并准备接受请求。默认是"NO PING QUERY SET"，这会导致多数数据库驱动失败时带有一个恰当的错误消息。
- `poolPingEnabled` – 是否启用侦测查询。若开启，也必须使用一个可执行的 SQL 语句设置 `poolPingQuery` 属性（最好是一个非常快的 SQL），默认值：false。
- `poolPingConnectionsNotUsedFor` – 配置 poolPingQuery 的使用频度。这可以被设置成匹配具体的数据库连接超时时间，来避免不必要的侦测，默认值：0（即所有连接每一时刻都被侦测 — 当然仅当 poolPingEnabled 为 true 时适用）。

###### JNDI

这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。

- `initial_context` – 这个属性用来在 InitialContext 中寻找上下文（即，initialContext.lookup(initial_context)）。这是个可选属性，如果忽略，那么 data_source 属性将会直接从 InitialContext 中寻找。
- `data_source` – 这是引用数据源实例位置的上下文的路径。提供了 initial_context 配置时会在其返回的上下文中进行查找，没有提供时则直接在 InitialContext 中查找。

##### 映射器

既然 MyBatis 的行为已经由上述元素配置完了，我们现在就要定义 SQL 映射语句了。但是首先我们需要告诉 MyBatis 到哪里去找到这些语句。 Java 在自动查找这方面没有提供一个很好的方法，所以最佳的方式是告诉 MyBatis 到哪里去找映射文件。你可以使用相对于类路径的资源引用， 或完全限定资源定位符（包括 `file:///` 的 URL），或类名和包名等。

<mappers>  <mapper resource="org/mybatis/builder/AuthorMapper.xml"/>  

<mapper resource="org/mybatis/builder/BlogMapper.xml"/>  

<mapper resource="org/mybatis/builder/PostMapper.xml"/> 

</mappers>

#### 映射文件

##### select

```
<select id="selectPerson" parameterType="int" resultType="hashmap">  SELECT * FROM PERSON WHERE ID = #{id} </select>    
<select #常用参数
  id="selectPerson"
  parameterType="int"
  parameterMap="deprecated"
  resultType="hashmap"
  resultMap="personResultMap"
  flushCache="false"
  useCache="true"
  timeout="10000"
  fetchSize="256"
  statementType="PREPARED"
  resultSetType="FORWARD_ONLY"> 
```



##### insert updata delete

```
<insert  id="insertAuthor"  parameterType="domain.blog.Author"  flushCache="true"  statementType="PREPARED"  keyProperty=""  keyColumn=""  useGeneratedKeys=""  timeout="20"> 
<update  id="updateAuthor"  parameterType="domain.blog.Author"  flushCache="true"  statementType="PREPARED"  timeout="20"> 
<delete  id="deleteAuthor"  parameterType="domain.blog.Author"  flushCache="true"  statementType="PREPARED"  timeout="20">
```

##### sql

这个元素可以被用来定义可重用的 SQL 代码段，可以包含在其他语句中。

<sql id="userColumns"> ${alias}.id,${alias}.username,${alias}.password </sql>

##### 参数

```
<select id="selectUsers" resultType="User">
  select id, username, password
  from users
  where id = #{id}
</select>
```

##### 字符串替换

${}这种方式接受从用户输出的内容并提供给语句中不变的字符串是不安全的，会导致潜在的 SQL 注入攻击，因此要么不允许用户输入这些字段，要么自行转义并检验。

##### ResultsMap （一张表中）

```
<!-- In mybatis-config.xml file --> 

<typeAlias type="com.someapp.model.User" alias="User"/> 

<!-- In SQL Mapping XML file --> 
<select id="selectUsers" resultType="User">  select id, username, hashedPassword  from some_table  where id = #{id} </select>
```

##### 高级结果映射 （多张表中）

<!-- Very Complex Statement --> 

```
<select id="selectBlogDetails" resultMap="detailedBlogResultMap">  
select       B.id as blog_id,       B.title as blog_title,       B.author_id as blog_author_id,       A.id as author_id,       A.username as author_username,       A.password as author_password,       A.email as author_email,       A.bio as author_bio,       A.favourite_section as author_favourite_section,       P.id as post_id,       P.blog_id as post_blog_id,       P.author_id as post_author_id,       P.created_on as post_created_on,       P.section as post_section,       P.subject as post_subject,       P.draft as draft,       P.body as post_body,       C.id as comment_id,       C.post_id as comment_post_id,       C.name as comment_name,       C.comment as comment_text,       T.id as tag_id,       T.name as tag_name  from Blog B       
left outer join Author A on B.author_id = A.id       
left outer join Post P on B.id = P.blog_id       
left outer join Comment C on P.id = C.post_id       
left outer join Post_Tag PT on PT.post_id = P.id       
left outer join Tag T on PT.tag_id = T.id  where B.id = #{id} 
</select>
```



#### 动态sql

###### if

```
<select id="findActiveBlogWithTitleLike"     resultType="Blog">  
SELECT * FROM BLOG   WHERE state = ‘ACTIVE’   
<if test="title != null">    
AND title like #{title}  
</if> 
</select>
```

##### choose when otherwise (Java 的 switch 语句，choose 为 switch，when 为 case，otherwise 则为 default。)

```
<select id="findActiveBlogLike"
     resultType="Blog">
  SELECT * FROM BLOG WHERE state = ‘ACTIVE’
  <choose>
    <when test="title != null">
      AND title like #{title}
    </when>
    <when test="author != null and author.name != null">
      AND author_name like #{author.name}
    </when>
    <otherwise>
      AND featured = 1
    </otherwise>
  </choose>
</select>
```

##### trim where set

where 会帮你自动修剪条件

```
<select id="findActiveBlogLike"
     resultType="Blog">
  SELECT * FROM BLOG 
  <where> 
    <if test="state != null">
         state = #{state}
    </if> 
    <if test="title != null">
        AND title like #{title}
    </if>
    <if test="author != null and author.name != null">
        AND author_name like #{author.name}
    </if>
  </where>
</select>
<trim prefix="WHERE" prefixOverrides="AND |OR ">  ...  </trim> 
```

set 元素可以被用于动态包含需要更新的列

```
<update id="updateAuthorIfNecessary">
  update Author
    <set>
      <if test="username != null">username=#{username},</if>
      <if test="password != null">password=#{password},</if>
      <if test="email != null">email=#{email},</if>
      <if test="bio != null">bio=#{bio}</if>
    </set>
  where id=#{id}
</update>
```

##### foreach

动态 SQL 的另外一个常用的必要操作是需要对一个集合进行遍历

```
<select id="selectPostIn" resultType="domain.blog.Post">
  SELECT *
  FROM POST P
  WHERE ID in
  <foreach item="item" index="index" collection="list"
      open="(" separator="," close=")">
        #{item}
  </foreach>
</select>
```

#### 目录结构

```
/my_application
  /bin
  /devlib
  /lib                <-- MyBatis *.jar文件在这里。
  /src
    /org/myapp/
      /action
      /data           <-- MyBatis配置文件在这里, 包括映射器类, XML配置, XML映射文件。
        /mybatis-config.xml
        /BlogMapper.java
        /BlogMapper.xml
      /model
      /service
      /view
    /properties       <-- 在你XML中配置的属性 文件在这里。
  /test
    /org/myapp/
      /action
      /data
      /model
      /service
      /view
    /properties
  /web
    /WEB-INF
      /web.xml
```



### 树形结构的



### 存储

设置一个 superId ,当数据是第一级树的时候，设置为空，通过一级查找二级，依次下去。

### 常用的Utils

OSUtils 负责不同的操作系统，路径的选择

TreeUtils 树形结构utils

BeanUtils 负责bean的操作

### JsonResponse

对返回值的封装，通过code 说明状态码，通过msg说明返回的信息，还有一个泛型的data,返回响应数据。

构造方法有JsonResponse()

JsonResponse( code,message);

JsonResponse(code,message,data)

静态方法success() , 返回一个code 为0，msg为空的JsonResponse 对象

静态方法success(T data),返回一个code 为0，msg为空的，值为data的JsonResponse 对象

静态方法success(String message,T data)，返回一个code为0，message ，数据是data的JsonResponse() 方法

静态方法fail(String message),返回状态码为1， message信息

静态方法fail(int code，String message)，返回状态为code，messge信息

### 用户权限控制



### 文件的导入导出

### docker



### Java基础

#### Java 中为什么只有值传递

java 中的对象采用的不是应用调用，而是值传递

#### hashCode()  和 equals

Object 中实现了 hashCode() ，hashCode() 是两个对象equals 前的操作，haCode() 的计算方法一般通过一个质数的乘法完成，比如String 的hashCode 是通过31*hash+string[i]，每个字符串有一个特定的hash，如果hash相同，他们可能equals，如果他们equals，那么他们的hash一定相同。hashCode 可以大大减小数据的之间的对比次数，如果比较两个string 是否equals 那么正常的思路就是一个个比，这样效率太差，可通过 hashCode 来先预判一下，两个string是否相等，提高效率，缩小查找的成本。两个 hashCode 值相等，这种叫 hash 冲突。

#### String StringBuilder StringBuffer

String 对象都是用 final 修饰的，内容不可变，但是指向是可以改变的

StringBuilder 是线程不安全的，通过apped 可以追加string 

StringBuffer 是线程安全的，通过append 可以追加string，所有的方法都是加了synchronized 的

#### 反射机制















​	